<!DOCTYPE html>
<html lang="en-us">

<head>
  <title>Java 并发：ConcurrentHashMap | Homeward</title>

  <meta charset="UTF-8">
  <meta name="language" content="en">
  <meta name="description" content="">
  <meta name="keywords" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  
  

  <link rel="shortcut icon" type="image/png" href="/favicon.ico" />


  
  
    
 
  
  
  
  
  
  
    
    <link type="text/css" rel="stylesheet" href="/css/post.min.400265c323f494e32126fcb28ee4a05b7ba081a303db212255f4debe5c212fdb.css" integrity="sha256-QAJlwyP0lOMhJvyyjuSgW3uggaMD2yEiVfTevlwhL9s="/>
  
    
    <link type="text/css" rel="stylesheet" href="/css/custom.min.e5f4131a78a2c54d461c7280ad6af3b12e08de11172a925616e18ae8f5abdddf.css" integrity="sha256-5fQTGniixU1GHHKArWrzsS4I3hEXKpJWFuGK6PWr3d8="/>
  
  
   
   
    

<script type="application/ld+json">
  
    {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/lil-q.github.io\/"
      },
      "articleSection" : "blog",
      "name" : "Java 并发：ConcurrentHashMap",
      "headline" : "Java 并发：ConcurrentHashMap",
      "description" : "",
      "inLanguage" : "en-US",
      "author" : "",
      "creator" : "",
      "publisher": "",
      "accountablePerson" : "",
      "copyrightHolder" : "",
      "copyrightYear" : "2021",
      "datePublished": "2021-06-13 16:30:25 \u002b0800 CST",
      "dateModified" : "2021-06-13 16:30:25 \u002b0800 CST",
      "url" : "https:\/\/lil-q.github.io\/blog\/concurrenthashmap\/",
      "wordCount" : "4206",
      "keywords" : ["Blog"]
    }
  
  </script>
</head>

<body>
  <div class="burger__container">
  <div class="burger" aria-controls="navigation" aria-label="Menu">
    <div class="burger__meat burger__meat--1"></div>
    <div class="burger__meat burger__meat--2"></div>
    <div class="burger__meat burger__meat--3"></div>
  </div>
</div>
 

  <nav class="nav" id="navigation">
  <ul class="nav__list">
    
    
      <li>
        <a  href="/">主页</a>
      </li>
    
      <li>
        <a  class="active"
         href="/blog">技术</a>
      </li>
    
      <li>
        <a  href="/picture">相册</a>
      </li>
    
  </ul>
</nav>


  <main>
    
    

    <div class="flex-wrapper">
      <div class="post__container">
        <div class="post">
          <header class="post__header">
            <h1 id="post__title">Java 并发：ConcurrentHashMap</h1>
            <time datetime="2021-06-13 16:30:25 &#43;0800 CST" class="post__date">Jun 13 2021</time> 
          </header>
          <article class="post__content">
              
<p><em>ConcurrentHashMap</em>（以下简称CHM） 对读取提供了<strong>完全</strong>的并发支持，对写入提供了<strong>高性能</strong>的并发支持。在读取数据时，<em>CHM</em> 无需上锁；而在写入数据时，也不用对整个 Map 上锁。</p>
<p>由于读取数据不上锁，读取时可能与写入发生重叠，<em>CHM</em> 只能反映最近完成的写入所产生的结果。与 volatile 类似，这也是符合 happens-before 原则的：如果通过 <em>CHM</em> 读取到某次写入后的值，那么写入前的程序的执行一定先于读取后的程序。</p>
<p>与 <em>CopyOnWriteArrayList</em> 相同，<em>CHM</em> 的迭代器在进行迭代时，不会因为写入或删除操作而报出 <em>ConcurrentModificationException</em>。但是，每次获得的迭代器只能被一个线程所使用，不应当传送给其他线程。一旦一个迭代器被创建，其状态就是确定的（一个快照），类似 <code>size()</code> \ <code>isEmpty()</code> \ <code>containsValue()</code> 等访问实时数据的函数就不能够用来控制程序了。</p>
<h2 id="一初始化">一、初始化<a class="anchor" href="#一初始化">#</a></h2>
<p><em>CHM</em> 中比较重要的成员变量如下：</p>
<pre><code class="language-java">public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
    implements ConcurrentMap&lt;K,V&gt;, Serializable {

	// 最大容量，hashcode前两位用作控制，所以最大为1&lt;&lt;30
    private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;

    // 默认容量
    private static final int DEFAULT_CAPACITY = 16;

    // 负载因子，需要扩容的键值对临界值和容量的比值，默认情况下用 n - (n &gt;&gt;&gt; 2) 实现
    private static final float LOAD_FACTOR = 0.75f;

    // 链表转化为红黑树的临界值
    static final int TREEIFY_THRESHOLD = 8;

    // 红黑树转化为链表的临界值
    static final int UNTREEIFY_THRESHOLD = 6;

    // 启用红黑树转化的最小容量，小于这个值时，优先扩容
    static final int MIN_TREEIFY_CAPACITY = 64;

    // 标记状态
    static final int MOVED     = -1; // hash for forwarding nodes
    static final int TREEBIN   = -2; // hash for roots of trees
    static final int RESERVED  = -3; // hash for transient reservations
    static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash
 
    // 现有表
    transient volatile Node&lt;K,V&gt;[] table;

    // 更新后的表
    private transient volatile Node&lt;K,V&gt;[] nextTable;
    
    /* 用来控制表的初始化和扩容,具有以下几种状态
     * -1  : 正在初始化
     * &lt; -1: 正在被-sizeCtl-1个线程扩容
     * &gt;= 0: 未初始化时，初始化的容量；初始化后，下一次扩容的容量。*/
    private transient volatile int sizeCtl;
}
</code></pre>
<p>初始化时，若未指定初始容量，根据默认值创建；若指定了初始容量，将 sizeCtl 设置为下一次扩容的容量，即乘以 1.5 倍后向上取整（2 的幂）。</p>
<pre><code class="language-java">public ConcurrentHashMap() {
}

// 指定大小
public ConcurrentHashMap(int initialCapacity) {
    if (initialCapacity &lt; 0)
        throw new IllegalArgumentException();
    // 下一次扩容的容量
    int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?
               MAXIMUM_CAPACITY :
               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1));
    this.sizeCtl = cap;
}

// 向上取整（2的幂）的快速算法
private static final int tableSizeFor(int c) {
    int n = c - 1;
    n |= n &gt;&gt;&gt; 1;
    n |= n &gt;&gt;&gt; 2;
    n |= n &gt;&gt;&gt; 4;
    n |= n &gt;&gt;&gt; 8;
    n |= n &gt;&gt;&gt; 16;
    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
</code></pre>
<p>不管是哪种初始化方式，都没有创建 table。这是一种懒加载策略，只有在第一次插入数据时，table 才会被创建。table 中存放着 <em>Node</em> 类保存的键值对，在设计时应保证其安全的发布。</p>
<pre><code class="language-java">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
    final int hash; // 不可变
    final K key; // 不可变
    volatile V val; // 可修改
    volatile Node&lt;K,V&gt; next;

    Node(int hash, K key, V val, Node&lt;K,V&gt; next) {
        this.hash = hash;
        this.key = key;
        this.val = val;
        this.next = next;
    }

    public final K getKey()       { return key; }
    public final V getValue()     { return val; }
    public final int hashCode()   { return key.hashCode() ^ val.hashCode(); }

    // 在其子类中将被重写，转化为红黑树后查找逻辑是不同的
    Node&lt;K,V&gt; find(int h, Object k) {
        Node&lt;K,V&gt; e = this;
        if (k != null) {
            do {
                K ek;
                if (e.hash == h &amp;&amp;
                    ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))
                    return e;
            } while ((e = e.next) != null);
        }
        return null;
    }
}
</code></pre>
<h2 id="二写入">二、写入<a class="anchor" href="#二写入">#</a></h2>
<p>为了尽可能减小锁的粒度，<em>CHM</em> 中引入了 <em>Unsafe</em> 提供的硬件支持的原子操作：</p>
<pre><code class="language-java">static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) {
    return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);
}

static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i,
                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) {
    return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);
}

static final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) {
    U.putObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v);
}
</code></pre>
<p><code>put()</code> 调用了 <code>putVal()</code>，传入 <code>putVal()</code> 的 onlyIfAbsent 表示是否只有在不存在相应 key 时才加入。可见 <code>put()</code> 始终传入 false，而另一个 public 方法 <code>putIfAbsent()</code> 则始终传入 true。<code>putValue()</code> 首先通过 <code>(hashcode ^ (hashcode &gt;&gt;&gt; 16)) &amp; HASH_BITS</code> 获取 hash 值。然后在一个循环中处理一下四种情况，直到跳出：</p>
<ul>
<li>table 未初始化：初始化 table；</li>
<li>table 已经初始化，但是相应桶为空：直接创建 <em>Node</em> 加入其中，跳出；</li>
<li>table 已经初始化，且相应桶不为空，但该桶正在迁移：当前线程将帮助迁移；</li>
<li>table 已经初始化，且相应桶不为空，且该桶未在迁移，将键值对加入桶中：
<ul>
<li>桶中是链表，遍历这个链表：
<ul>
<li>若存在：直接修改 value，跳出；</li>
<li>若不存在：创建新 <em>Node</em> 加到尾部，跳出。</li>
</ul>
</li>
<li>桶中是红黑树：通过 <em>TreeNode</em> 中 <code>putTreeValue()</code> 写入，逻辑与上面类似，跳出。</li>
</ul>
</li>
</ul>
<p>在完成上面步骤之后，还会检查 binCount，如果满足转化红黑树的条件则进行转化。</p>
<pre><code class="language-java">public V put(K key, V value) {
    return putVal(key, value, false);
}

// onlyIfAbsent为true时，只能添加不能修改
final V putVal(K key, V value, boolean onlyIfAbsent) {
    if (key == null || value == null) throw new NullPointerException();
    int hash = spread(key.hashCode()); // 取有效hash
    int binCount = 0; // 计算桶内个数，用以控制扩容或树的转化
    for (Node&lt;K,V&gt;[] tab = table;;) { // 循环，直到写入完成跳出
        Node&lt;K,V&gt; f; int n, i, fh;
        if (tab == null || (n = tab.length) == 0)
            tab = initTable(); // 【未初始化则先初始化】
        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {
            if (casTabAt(tab, i, null,
                         new Node&lt;K,V&gt;(hash, key, value, null)))
                break; // 桶为空，通过原子操作写入，不需要加锁
        }
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f); // 该节点正在迁移，该线程也帮助迁移
        else {
            V oldVal = null;
            synchronized (f) {
                if (tabAt(tab, i) == f) { // 上锁和检查头节点是否有变
                    if (fh &gt;= 0) { // 大于等于0，则为链表
                        binCount = 1;
                        for (Node&lt;K,V&gt; e = f;; ++binCount) { // 遍历同时记录binCount
                            K ek;
                            if (e.hash == hash &amp;&amp;
                                ((ek = e.key) == key ||
                                 (ek != null &amp;&amp; key.equals(ek)))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break; // 找到了，则修改
                            }
                            Node&lt;K,V&gt; pred = e;
                            if ((e = e.next) == null) {
                                pred.next = new Node&lt;K,V&gt;(hash, key,
                                                          value, null);
                                break; // 没找到，则添加在尾部
                            }
                        }
                    }
                    else if (f instanceof TreeBin) { // 处理红黑树
                        Node&lt;K,V&gt; p;
                        binCount = 2;
                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                              value)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                }
            }
            if (binCount != 0) {
                if (binCount &gt;= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i); // 【链表长度超过临界，转化为红黑树或者扩容】
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    addCount(1L, binCount); // 【计数，超过sizeCtl会进行扩容】
    return null;
}
</code></pre>
<p><code>putVal()</code> 中有三个函数是重点：<code>initTable()</code> \ <code>treeifyBin()</code> \ <code>addCount</code>。 <code>initTable()</code>必须要保证只有一个线程对 table 进行初始化。<code>treeifyBin()</code> 和 <code>addCount</code> 中都包含了扩容操作，但是扩容的结果却是不同的。为了便于区分，我们将 <code>treeifyBin()</code> 中使用 <code>tryPresize()</code> 进行的扩容称为 P 扩容，而将由 <code>addCount()</code> 进行的扩容称为 C 扩容。</p>
<h3 id="21-inittable">2.1 initTable<a class="anchor" href="#21-inittable">#</a></h3>
<p>不管是初始化 table 还是对 table 进行扩容，sizeCtl 都是至关重要的一环。在初始化 table 时，并不能保证只有当前线程需要初始化，当有多个线程同时初始化 table 时，竞争就出现了。通过 sizeCtl 处理竞争很容易，若当前线程赢得了竞争，开始初始化，则把 sezeCtl 设置为 -1（这个操作必须原子性的）。其他线程在读到 sizeCtl = -1 时就放弃初始化，进而 <code>yield()</code> 让出资源等待初始化的完成，这就是为什么需要 while 循环的原因。但是这里还有两个问题：</p>
<ol>
<li>为什么在检查 table 是否初始化时需要 <code>(tab = table) == null || tab.length == 0</code>，似乎 <code>tab.length == 0</code> 总是不能单独成立的？</li>
<li>为什么最后的 <code>sizeCtl = sc</code> 需要 finally 句式来保证其一定执行。</li>
</ol>
<p>第一个问题我还没有答案，不过第二问题有以下解释。在创建新的 table 时，可能会因为空间不足而报出 <code>OutOfMemoryError</code>，该线程就无法执行下去，如果没有 finally 保证 <code>sizeCtl = sc</code> 一定执行，sizeCtl 将永远为 -1，而 table 也将永远无法创建。</p>
<pre><code class="language-java">private final Node&lt;K,V&gt;[] initTable() {
    Node&lt;K,V&gt;[] tab; int sc;
    while ((tab = table) == null || tab.length == 0) {
        if ((sc = sizeCtl) &lt; 0)
            Thread.yield(); // lost initialization race; just spin
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
            try {
                if ((tab = table) == null || tab.length == 0) {
                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;
                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];
                    table = tab = nt;
                    sc = n - (n &gt;&gt;&gt; 2);
                }
            } finally {
                sizeCtl = sc;
            }
            break;
        }
    }
    return tab;
}
</code></pre>
<h3 id="22-treeifybin">2.2 treeifyBin<a class="anchor" href="#22-treeifybin">#</a></h3>
<p>如果插入一个键值对后，链表长度大于等于 TREEIFY_THRESHOLD，就需要进行扩容或转化红黑树。<code>treeifyBin()</code> 是这一操作的入口，首先判断 table 容量是否小于 MIN_TREEIFY_CAPACITY，如果是则进行 P 扩容（由 <code>tryPresize()</code> 进行的，有别于下文中由 <code>addCount()</code> 进行的），否则进行红黑树转化。</p>
<pre><code class="language-java">private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) {
    Node&lt;K,V&gt; b; int n, sc;
    if (tab != null) {
        if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY) // 扩容
            tryPresize(n &lt;&lt; 1); 
        else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) { // 转化红黑树
            synchronized (b) {
                if (tabAt(tab, index) == b) {
                    TreeNode&lt;K,V&gt; hd = null, tl = null;
                    for (Node&lt;K,V&gt; e = b; e != null; e = e.next) {
                        TreeNode&lt;K,V&gt; p =
                            new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,
                                              null, null);
                        if ((p.prev = tl) == null)
                            hd = p;
                        else
                            tl.next = p;
                        tl = p;
                    }
                    setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));
                }
            }
        }
    }
}
</code></pre>
<h3 id="23-addcount">2.3 addCount<a class="anchor" href="#23-addcount">#</a></h3>
<p><code>addCount()</code> 通过一个 <em>CounterCell</em> 数组计算键值对个数，虽然只是简单的计数，但为了尽可能减少线程冲突，其中蕴含了非常巧妙的设计。这部分内容将在第四章中介绍。</p>
<p><code>addCount()</code> 中的 check 用来标识是否需要考虑扩容，<code>putVal()</code>调用时， check 值实际上就是 <code>putVal()</code> 中的 binCount，有以下可能：</p>
<ul>
<li>写入前桶内为空：0；</li>
<li>写入前桶内为链表：写入的节点位置；</li>
<li>写入前桶内为红黑树：2。</li>
</ul>
<p>当 check 大于等于 0 且满足以下三个条件时，就需要进行 C 扩容：</p>
<ol>
<li>键值对数达到sizeCtl；</li>
<li>table非空；</li>
<li>table长度非最大值。</li>
</ol>
<p>实际上，C 扩容的步骤和 <code>tryPresize()</code> 中的一个分支完全一致，可以理解为 C 扩容是 P 扩容的一个子集，这部分将在下一章中介绍。</p>
<pre><code class="language-java">private final void addCount(long x, int check) {
    // 计数部分,暂不考虑
    CounterCell[] as; long b, s;
    ...
        s = sumCount(); // 键值对数

    // 判断是否C扩容
    if (check &gt;= 0) { 
        Node&lt;K,V&gt;[] tab, nt; int n, sc;
        // 满足三个条件则C扩容：1.键值对数达到sizeCtl；2.table非空；3.table长度非最大值
        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;
               (n = tab.length) &lt; MAXIMUM_CAPACITY) {
            // 以下为C扩容，和tryPresize()中的一个分支完全一致
            int rs = resizeStamp(n);
            if (sc &lt; 0) {
                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                    transferIndex &lt;= 0)
                    break;
                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                    transfer(tab, nt);
            }
            else if (U.compareAndSwapInt(this, SIZECTL, sc,
                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))
                transfer(tab, null);
            s = sumCount();
        }
    }
}
</code></pre>
<h2 id="三扩容">三、扩容<a class="anchor" href="#三扩容">#</a></h2>
<p><em>CHM</em> 的扩容非常有趣，正如上文所说，当前线程如果发现自己要处理的桶正在迁移，并不会干等着，而是利用自己的计算资源帮助完成整个 table 的迁移。</p>
<p>另一个有趣的点是，对于同样长度的 table，可能扩容出不同长度的新 table。来看下面一个例子：</p>
<pre><code class="language-java">// 测试例
public class ConcurrentMapTest {
    public static void main(String[] args)
            throws NoSuchFieldException, IllegalAccessException {
        final int DEFAULT_CAPACITY = 16; // 默认容量
        ConcurrentHashMap&lt;Integer, Integer&gt; map1 = new ConcurrentHashMap&lt;&gt;();
        ConcurrentHashMap&lt;Integer, Integer&gt; map2 = new ConcurrentHashMap&lt;&gt;();
        // c扩容
        for (int i = 0; i &lt; 12; i++) {
            map1.put(i, i); // key不同
            int length;
            if ((length = getLength(map1)) != DEFAULT_CAPACITY) {
                System.out.printf(&quot;第%d次插入后map1扩容：%d\n&quot;, i + 1, length);
                break;
            }
        }
        // p扩容
        for (int i = 0; i &lt; 12; i++) {
            map2.put(i * 16, i); // key不同
            int length;
            if ((length = getLength(map2)) != DEFAULT_CAPACITY) {
                System.out.printf(&quot;第%d次插入后map2扩容：%d\n&quot;, i + 1, length);
                break;
            }
        }
    }

    // 通过反射获取table.length
    private static int getLength(ConcurrentHashMap map)
            throws NoSuchFieldException, IllegalAccessException {
        Field tableField = ConcurrentHashMap.class.getDeclaredField(&quot;table&quot;);
        tableField.setAccessible(true);
        Object[] table = (Object[]) tableField.get(map);
        return (table == null ? 0 : table.length);
    }
}

</code></pre>
<pre><code class="language-txt">第12次插入后map1扩容：32
第9次插入后map2扩容：128
</code></pre>
<p>上面两个 map 扩容后出现了不同的容量，这是因为两者触发了不同的扩容机制。map1 中每次插入的 key 为 1、2、3 等，由于 <em>Integer</em> 的 hashcode 等于其自身的开箱值，可以确保 map1 中的键值对是均匀分布的。因此，导致 map1 扩容的原因是键值对的数量达到sizeCtl（12）。map2 中每次插入的是 16 的倍数，所以每次插入的键值对都放进了第一个桶内，这导致第一个桶的链表越来越长，当长度大于 TREEIFY_THRESHOLD（8）时，触发了 <code>treeifyBin()</code>，根据 <code>treeifyBin()</code> 的逻辑，map2 当前容量小于 MIN_TREEIFY_CAPACITY（64），优先通过 <code>tryPresize()</code> 进行 P 扩容。</p>
<h3 id="31-p-扩容">3.1 P 扩容<a class="anchor" href="#31-p-扩容">#</a></h3>
<p>从上面的测试例可以看出，P 扩容正好是 C 扩容的四倍，这是巧合吗？上一章节中，我们已经对 <code>addCount()</code> 有了初步的认识，它会先计数，然后根据计数判断是否进行 C 扩容。在具体分析 C 扩容前，先来看看 <code>tryPresize()</code> 是如何实现 P 扩容的，也许能找到他们之间的一些联系。</p>
<p>首先  <code>tryPresize()</code> 会获得一个扩容要求 c，他是由传入 size 乘以 1.5 倍后向上舍入得到的。例如，初始 table.length=16，传入 size=32，可以得到 c=64。得到 c 后，通过 while 循环不断检验 sizeCtl 是否大于 c，有以下分支：</p>
<ul>
<li>table 未初始化：初始化 table；</li>
<li>sizeCtl &gt;= c：扩容完毕，跳出；</li>
<li>其他：进行 C 扩容。</li>
</ul>
<p>现在我们知道，P 扩容实际上提供了 table 的初始化（在对空 map 进行 <code>putAll()</code> 时需要）和扩容的终止条件，其余时间都是在循环 C 扩容。上面的例子中，P 扩容后容量是 C 扩容的四倍，说明 P 扩容进行了三次 C 扩容。</p>
<ol>
<li>
<p>table.length=32，c=64 &gt; sizeCtl=24；</p>
</li>
<li>
<p>table.length=64，c=64 &gt; sizeCtl=48；</p>
</li>
<li>
<p>table.length=128，c=64 &lt; sizeCtl=96，跳出。</p>
</li>
</ol>
<p>总结，C 扩容将 table.length 翻倍，而 P 扩容进行若干次 C 扩容，直到满足条件。之所以 P 扩容比 C 扩容大得多，是因为触发 P 扩容时，map 已经察觉到明显的哈希冲突了。</p>
<pre><code class="language-java">// 注意: 如果是由treeifyBin()调用，传入的size已经是两倍的原table长度
private final void tryPresize(int size) {
    int c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY :
    tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1); // 获得扩容要求c
    int sc;
    while ((sc = sizeCtl) &gt;= 0) {
        Node&lt;K,V&gt;[] tab = table; int n;
        // 如果table没初始化，先初始化
        if (tab == null || (n = tab.length) == 0) {
            n = (sc &gt; c) ? sc : c;
            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
                try {
                    if (table == tab) {
                        @SuppressWarnings(&quot;unchecked&quot;)
                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];
                        table = nt;
                        sc = n - (n &gt;&gt;&gt; 2);
                    }
                } finally {
                    sizeCtl = sc;
                }
            }
        }
        // 满足扩容要求，扩容完毕，跳出
        else if (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)
            break;
        // 与C扩容一致
        else if (tab == table) {
            int rs = resizeStamp(n); // 获得扩容标志rs
            // 有其他线程正在扩容
            if (sc &lt; 0) {
                Node&lt;K,V&gt;[] nt;
                // 出现以下情况不应该帮助迁移，见下文
                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                    transferIndex &lt;= 0)
                    break;
                // 原子操作将sizeCtl中的线程数加一
                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                    // 把table迁移到nextTable
                    transfer(tab, nt);
            }
            // 没有其他线程在扩容，通过原子操作尝试扩容，把sizeCtl设置为相应负数
            // 原子操作成功，将(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)赋值给sizeCtl
            else if (U.compareAndSwapInt(this, SIZECTL, sc,
                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))
                // 创建一个两倍长度的新table，并赋值到nextTable上
                // 开始迁移
                transfer(tab, null);
        }
    }
}
</code></pre>
<h3 id="32-c-扩容">3.2 C 扩容<a class="anchor" href="#32-c-扩容">#</a></h3>
<p>C 扩容的逻辑相对简单，但要理解它却比较困难，罪魁祸首就是我们老朋友 sizeCtl！</p>
<p>源码中的注解表示，当多个线程同时进行扩容时，sizeCtl=-(1+N)，其中 N 表示正在扩容的线程数。如果按照这个逻辑，在扩容时，sizeClt 应当是一个比较接近 0 的负数， 但事实上 sizeCtl 通常都是一个非常小的负数。出现这种情况的原因是 sizeCtl 的高 16 位被用来标识 table 了，其低 16 位才标识 1+N。先来看扩容标识 rs 是怎么获得的。</p>
<pre><code class="language-java">static final int resizeStamp(int n) {
    // 取前导0的个数，并把低16位的第一位置1              RESIZE_STAMP_BITS默认16
    return Integer.numberOfLeadingZeros(n) | (1 &lt;&lt; (RESIZE_STAMP_BITS - 1));
}
</code></pre>
<p>为了方便理解，还是以初始长度为 16 的 table 为例，前导零一共 27 个，可得：</p>
<pre><code class="language-txt">rs = 0000 0000 0000 0000 1000 0000 0010 0111
                        (置1)           (27)
</code></pre>
<p>有了扩容标识 rs 后，判断 sizeCtl，如果 sizeCtl 为负，说明有其他线程正在扩容；如果 sizeCtl 非负，则通过原子操作将 sizeCtl 设置为相应负数，原子操作成功就开始扩容。</p>
<pre><code class="language-java">U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2);
// 原子操作成功，则siztCtl = 1000 0000 0010 0111 0000 0000 0000 0010   
</code></pre>
<p>原子操作成功后，sizeCtl 就变成了一个很小的负数，事实上，我们不应该关注这个值本身的大小，只需要关心其高 16 位和低 16 位的真正含义就可以了。sizeCtl 修改完毕后，<code>transfer(tab, null)</code> 将先创建一个两倍长度的 nextTable，然后开始将 table 上的数据迁移到 nextTable 上。</p>
<p>这时候其他线程就会觉察到正在迁移（sizeCtl&lt;0）并试图帮助迁移。首先判断是否有资格帮助迁移，以下情况将不予参与扩容并直接跳出：</p>
<ul>
<li>(sc &raquo;&gt; RESIZE_STAMP_SHIFT) != rs：扩容标识对不上，说明不是同一 table，帮不上忙；</li>
<li>sc == rs + 1：扩容已经结束，收工了；</li>
<li>sc == rs + MAX_RESIZERS：已经达到最大扩容线程数，人手够了；</li>
<li>(nt = nextTable) == null：nextTab还没创建，工厂还没建完；</li>
<li>transferIndex &lt;= 0：所有桶都已经分配出去，来晚了一步。</li>
</ul>
<p>如果有资格参与扩容，就进行一次原子操作对 sizeCtl 加一，成功就可以 <code>transfer(tab, nt)</code>，将 table 中的数据迁移到 nextTable。</p>
<h3 id="33-transfer">3.3 transfer<a class="anchor" href="#33-transfer">#</a></h3>
<p>终于，关于扩容只剩下最后一个问题需要搞清楚——table 和 nextTable 之间的数据是如何迁移的。</p>
<p><code>transfer()</code> 非常长，包含了很多逻辑，仔细拆分后能更好理解。我们首先列出总体框架，然后对细节进行推敲。</p>
<pre><code class="language-java">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) {
    int n = tab.length, stride;
    // 1.根据CPU数确定划分table的步长
    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)
        stride = MIN_TRANSFER_STRIDE; // subdivide range
    // 2.若传入的nextTab为null，则创建nextTable
    if (nextTab == null) { // initiating
        try {
            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];
            nextTab = nt;
        } catch (Throwable ex) { // try to cope with OOME
            sizeCtl = Integer.MAX_VALUE;
            return;
        }
        nextTable = nextTab;
        transferIndex = n; // 用于控制扩容区间的分配
    }
    int nextn = nextTab.length;
    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab); // 用于标记已处理的空桶
    boolean advance = true;
    boolean finishing = false; // to ensure sweep before committing nextTab
    // 3.循环处理，i表示当前处理的桶下标（原table），bound表示分得区间的下界
    for (int i = 0, bound = 0;;) {
        Node&lt;K,V&gt; f; int fh;
        // 领取区间 / 控制桶的序号 i--
        while (advance) {
            ... // 详见3.3.1节
        }
        // 判断是否结束
        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) {
            ... // 详见3.3.2节
        }
        // 当前桶为空，插入一个 fwd
        else if ((f = tabAt(tab, i)) == null)
            advance = casTabAt(tab, i, null, fwd);
        // 当前桶已经迁移
        else if ((fh = f.hash) == MOVED)
            advance = true; // already processed
        // 迁移桶内数据
        else {
            synchronized (f) {
                if (tabAt(tab, i) == f) {
                    Node&lt;K,V&gt; ln, hn;
                    // 处理节点是链表的情况
                    if (fh &gt;= 0) {
                        ... // 详见3.3.3节
                    }
                    // 处理节点是红黑树的情况
                    else if (f instanceof TreeBin) {
                        ... // 详见3.3.3节
                    }
                }
            }
        }
    }
}
</code></pre>
<p>我们先将 <code>transfer()</code> 拆分为以下几个部分：</p>
<ol>
<li>根据 CPU 数确定划分 table 的步长：
<ul>
<li>如果是单核 CPU，步长就是 table.length；</li>
<li>如果是多核 CPU，步长为 <code>max((n &gt;&gt;&gt; 3) / NCPU, MIN_TRANSFER_STRIDE)</code>。</li>
</ul>
</li>
<li>若传入的 nextTab 为 null，则创建 nextTable：
<ul>
<li>将创建的 nextTab 赋给全局变量 nextTable；</li>
<li>将用于控制扩容区间的分配 transferIndex 初始化为 table.length。</li>
</ul>
</li>
<li>开始循环处理区间内各个桶得迁移，由 advance 控制程序：
<ul>
<li>while 循环对区间 [bound, i] 进行分配或调整（&ndash;i）；</li>
<li>开始下面四个分支：
<ul>
<li>i 越界：判断当前区间的迁移是否结束；</li>
<li>当前桶为空：插入一个 fwd；</li>
<li>当前桶已经迁移：跳过；</li>
<li>其他：迁移桶内数据，包括链表和红黑树。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>首先，根据 CPU 的核心数来划分迁移的步长，步长就是每个线程需要处理的桶个数。如果是单核，由于没有并行能力，线程直接处理整个 table 即可；如果是多线程，通过 <code>(n &gt;&gt;&gt; 3) / NCPU</code> 计算步长，但是必须要大于 MIN_TRANSFER_STRIDE，默认 16。</p>
<p>接着，如果传入的 nextTab 为 null，就需要创建 nextTable 并赋值给全局变量。同时，将全局变量 transferIndex 设为 table.length，这个变量告诉所有线程迁移进行到了哪个分区。</p>
<p>最后开始一个循环，每次循环处理一个桶，先对区间进行控制，然后由四个分支处理。这四个分支中，当前桶为空和当前桶已迁移比较简单。</p>
<p>当前桶为空的情况，会插入一个 <em>ForwardingNode</em> 类的 fwd，它的状态码为 MOVED。当其他线程进行对该桶 <code>putVal()</code> 时，会调用 <code>helpTransfer()</code> 帮助迁移；其他线程对该桶迁移时，则会直接跳过。最后把 advance 设置为插入 fwd 的原子操作的返回值，如果成功了下一个循环将迁移下一个桶或结束，如果失败了下一个循环还会继续处理当前桶。</p>
<p>当前桶已迁移的情况，直接跳过，将 advance 设置为 true。</p>
<p>剩下还有三个部分需要继续分析：控制区间、结束条件和迁移数据。</p>
<h4 id="331-控制区间">3.3.1 控制区间</h4>
<p>在 <code>for (int i = 0, bound = 0;;)</code> 中初始化了两个变量 bound 和 i，bound 表示区间下界，i 表示当前处理桶的下标。</p>
<pre><code class="language-java">while (advance) {
    int nextIndex, nextBound;
    // 选择下一个桶或处理结束信号
    if (--i &gt;= bound || finishing)
        advance = false;
    // 没有新的区间可以分配
    else if ((nextIndex = transferIndex) &lt;= 0) {
        i = -1;
        advance = false;
    }
    // 分配区间
    else if (U.compareAndSwapInt
             (this, TRANSFERINDEX, nextIndex,
              nextBound = (nextIndex &gt; stride ?
                           nextIndex - stride : 0))) {
        bound = nextBound;
        i = nextIndex - 1;
        advance = false;
    }
}
</code></pre>
<p>第一次循环前两个分支都不成立，将由分支三分配区间。假设原 table 的长度为 64，步长 strde 为 16，控制区间的过程大致如下：</p>
<ol>
<li>初始状态下，transferIndex=64；</li>
<li>分配区间，通过原子操作将 transferIndex 减 stride，将修改后的 transferIndex 赋值给 bound，将修改前的 transferIndex 赋值给 i；</li>
<li>对 i 自减 1，不断处理每一个桶；</li>
<li>当 i 小于 bound 时，触发下一次分配。</li>
</ol>
<pre><code class="language-txt">1.  |————————|————————|————————|————————|
    0                                    transferIndex=64


2.  |————————|————————|————————|————————|
    0                           transferIndex=48
                                bound=48    
                                        i=63

3.  |————————|————————|————————|————————|
    0                           transferIndex=48
                                bound=48   
                                       i=62 
                                            
    |————————|————————|————————|————————|
    0                           transferIndex=48
                                bound=48   
                               i=47 

4.  |————————|————————|————————|————————|
    0                  transferIndex=32
                       bound=32    
                               i=47
</code></pre>
<h4 id="332-结束条件">3.3.2 结束条件</h4>
<p>判断结束条件围绕 finishing 变量展开，当 i 小于 0 时，当前线程已经完成了 table 最后的一个区间，对 finishing 进行判断：</p>
<ul>
<li>finishing 为 true：
<ul>
<li>全局变量 nextTable 置空；</li>
<li>替换 table；</li>
<li>设置 sizeCtl。</li>
</ul>
</li>
<li>finishing 为 false：
<ul>
<li>原子操作对 sizeCtl 中的线程数减 1；</li>
<li>判断是否所有线程都结束工作，否则返回，是则继续；</li>
<li>finishing 置 true。</li>
<li>i 置 taable.length，下一个循环开始全局检查。</li>
</ul>
</li>
</ul>
<pre><code class="language-java">// i&lt;0时，已经完成扩容，暂不知道(i&gt;=n || i+n&gt;=nextn)的含义
if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) {
    int sc;
    // finishing为true则结束
    if (finishing) {
        nextTable = null; // 置空
        table = nextTab; // 替换
        sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); // sizeCtl设为0.75倍的table.length
        return;
    }
    // finishing为false，但是该线程的任务已经完成，sizeCtl中的线程数减1
    if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {
        // 判断sizeCtl是否回到刚开始扩容的状态，是则说明所有用于迁移的线程都结束工作，否则直接返回
        if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)
            return;
        // finishing置为true
        finishing = advance = true;
        // i置为table.length，全部扫描一遍，确定所有桶都已经完成迁移
        i = n; // recheck before commit
    }
}
</code></pre>
<h4 id="333-迁移链表">3.3.3 迁移链表</h4>
<p>迁移的逻辑和 HashMap 类似，对于节点 node，将其 hash 码和 table.length 进行位与，由于 table.length 总是 2 的幂，位与的结果不是 0 就是 table.length。将得到 0 的 node 放在低位桶，其余放在高位桶。</p>
<pre><code class="language-java">// 上锁，与putVal()同步，f为当前桶的头节点
synchronized (f) {
    if (tabAt(tab, i) == f) {
        Node&lt;K,V&gt; ln, hn;
        // hash&gt;0为链表，树节点的hash=-2
        if (fh &gt;= 0) {
            // 决定移动到低位桶还是高位桶
            int runBit = fh &amp; n;
            Node&lt;K,V&gt; lastRun = f;
            // 找到最后将迁移到同一个桶的所有节点，这部分不需要创建新的节点，而是直接迁移
            for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) {
                int b = p.hash &amp; n;
                if (b != runBit) {
                    runBit = b;
                    lastRun = p;
                }
            }
            if (runBit == 0) {
                ln = lastRun;
                hn = null;
            }
            else {
                hn = lastRun;
                ln = null;
            }
            // 根据每个节点的hash值迁移，由于节点中的key是不可变的，需要创建新的节点
            for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) {
                int ph = p.hash; K pk = p.key; V pv = p.val;
                if ((ph &amp; n) == 0)
                    // 头插法，创建新节点时把自己作为next节点传入
                    // 最后链表的顺序将会颠倒（除了lastRun之后的）
                    ln = new Node&lt;K,V&gt;(ph, pk, pv, ln); 
                else
                    // 同上
                    hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);
            }
            setTabAt(nextTab, i, ln); // 原子操作把低位桶置入新表
            setTabAt(nextTab, i + n, hn); // 原子操作把高位桶置入新表
            setTabAt(tab, i, fwd); // 原子操作把fwd置入旧表表示已经迁移
            advance = true;
        }
        else if (f instanceof TreeBin) {
            ...
        }
    }
}
</code></pre>
<p>我们以长度为 8 的 table 为例，在 table 的第一个桶内插入了 9 条数据，这时候触发了扩容。用 [key] 表示这些 key 的值，并求得每一个节点的 runBit。对这些节点遍历，找到 lastRun 的位置。</p>
<pre><code class="language-txt">| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |  &lt;-table
 [0] : 0000 0000 &amp; 1000 = 0 
 [8] : 0000 1000 &amp; 1000 = 8
 [16]: 0001 0000 &amp; 1000 = 0
 [24]: 0001 1000 &amp; 1000 = 8
 [32]: 0010 0000 &amp; 1000 = 0
 [40]: 0010 1000 &amp; 1000 = 8
 [48]: 0011 0000 &amp; 1000 = 0  &lt;-lastRun 
 [64]: 0100 0000 &amp; 1000 = 0
 [80]: 0101 0000 &amp; 1000 = 0
 [key]                  runBit 
</code></pre>
<p>再次遍历所有节点直到 lastRun 为止，不断把节点添加到 ln 和 hn 上。由于遍历顺序和添加节点的顺序相反，最后链表的顺序将会颠倒（除了 lastRun 之后的）。</p>
<pre><code class="language-txt">  ln                              hn
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |  &lt;-newTable
 [32]   -                        [40]  -
 [16]   -                        [24]  -
 [0]   &lt;- reversed               [8]  &lt;- reversed 
 [48]  &lt;- lastRun
 [64]    
 [80]    
</code></pre>
<h4 id="334-迁移红黑树">3.3.4 迁移红黑树</h4>
<p>红黑树的迁移与链表类似，只是处理数据结构不同。不过需要注意红黑树拆分后可能就不足 UNTREEIFY_THRESHOLD，默认 6，这时候需要转化为链表。</p>
<pre><code class="language-java">synchronized (f) {
    if (tabAt(tab, i) == f) {
        Node&lt;K,V&gt; ln, hn;
        if (fh &gt;= 0) {
            ...
        }
        // 节点为红黑树
        else if (f instanceof TreeBin) {
            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;
            TreeNode&lt;K,V&gt; lo = null, loTail = null;
            TreeNode&lt;K,V&gt; hi = null, hiTail = null;
            int lc = 0, hc = 0;
            // 遍历
            for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) {
                int h = e.hash;
                TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;
                    (h, e.key, e.val, null, null);
                // 和链表相同的判断，与运算==0的放在低位
                if ((h &amp; n) == 0) {
                    if ((p.prev = loTail) == null)
                        lo = p;
                    else
                        loTail.next = p;
                    loTail = p;
                    ++lc;
                } // 不是0的放在高位
                else {
                    if ((p.prev = hiTail) == null)
                        hi = p;
                    else
                        hiTail.next = p;
                    hiTail = p;
                    ++hc;
                }
            }
            // 如果树的节点数小于等于 6，那么转成链表，反之，创建一个新的树
            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :
            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;
            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :
            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;
            // 低位树
            setTabAt(nextTab, i, ln);
            // 高位数
            setTabAt(nextTab, i + n, hn);
            // 旧的设置成占位符
            setTabAt(tab, i, fwd);
            // 继续向后推进
            advance = true;
        }
    }
}
</code></pre>
<h2 id="四计数">四、计数<a class="anchor" href="#四计数">#</a></h2>
<p>通过 <code>size()</code> 可以获得当前键值对的数量，<code>size()</code> 将 <code>sumCount()</code> 获得的 long 类型的值转化为 int 返回。</p>
<p><code>sumCount()</code> 则计算 baseCount 字段与 counterCells 数组中所有非空元素的记录值的和。</p>
<pre><code class="language-java">// 未发生争用前都用它计数
private transient volatile long baseCount;

// 用于同步counterCells数组结构修改的乐观锁资源
private transient volatile int cellsBusy;

// 支持多个线程同时通过counterCells中的多个元素计数
private transient volatile CounterCell[] counterCells;

public int size() {
    long n = sumCount();
    return ((n &lt; 0L) ? 0 : 
            (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE : 
            (int)n); 
}

// 计算 baseCount 字段与所有 counterCells 数组的非空元素的和
final long sumCount() {
    CounterCell[] as = counterCells; CounterCell a;
    long sum = baseCount;
    if (as != null) {
        for (int i = 0; i &lt; as.length; ++i) {
            if ((a = as[i]) != null)
                sum += a.value;
        }
    }
    return sum;
}
</code></pre>
<p>由此我们可以推断，<em>CHM</em> 将键值对数量保存在全局变量 baseCount 和 <em>CounterCell</em> 数组 counterCells 中。<em>CounterCell</em> 是 <em>CHM</em> 的静态内部类，结构很简单，仅仅保存一个 volatile 修饰的 long 值。因此，每一个 <em>CounterCell</em> 对象占用空间都很小，当一个 <em>CounterCell</em> 数组创建时，其中的多个元素可能处在同一缓存行内，这会导致一种伪共享的现象，极大降低并发效率。</p>
<p><code>@sun.misc.Contended</code> 的作用就是保证修饰对象不会出现伪共享，原理是在对象或字段的前后各增加 128 字节大小的 padding，使用 2 倍于大多数硬件缓存行的大小来避免相邻扇区预取导致的伪共享冲突。</p>
<pre><code class="language-java">@sun.misc.Contended static final class CounterCell {
    volatile long value;
    CounterCell(long x) { value = x; }
}
</code></pre>
<p>那么键值对的数量是如何保存到 baseCount 和 counterCells 中的呢?</p>
<p>在第二章中，我们介绍了 <code>addCount()</code>，它会先对 <em>CHM</em> 中所有键值对计数，然后考虑是否扩容。现在我们来看看它是如何计数的。</p>
<pre><code class="language-java">private final void addCount(long x, int check) {
    CounterCell[] as; long b, s;
    // 第一层if
    if ((as = counterCells) != null ||
        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {
        CounterCell a; long v; int m;
        boolean uncontended = true;
        // 第二层if
        if (as == null || (m = as.length - 1) &lt; 0 ||
            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null ||
            !(uncontended =
              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {
            fullAddCount(x, uncontended);
            return;
        }
        if (check &lt;= 1)
            return;
        s = sumCount();
    }
    if (check &gt;= 0) {
        ...
    }
}
</code></pre>
<p><code>addCount()</code> 中有两层 if，其中蕴含了非常巧妙的设计，第一层：</p>
<ul>
<li>counterCells 不为空：跳转第二层 if；</li>
<li>counterCells 为空：不着急创建 counterCells，先用原子操作增加 baseCount：
<ul>
<li>成功：结束计数；</li>
<li>失败：跳转第二层 if。</li>
</ul>
</li>
</ul>
<p>第二层 if 就是用来创建 counterCells 以及使用它来计数的：</p>
<ul>
<li>counterCells 为空或 counterCells[probe] 为空：调用 <code> fullAddCount(x, true)</code>；</li>
<li>counterCells[probe] 已经创建：原子操作增加其 value 值：
<ul>
<li>成功：结束计数；</li>
<li>失败：调用 <code> fullAddCount(x, false)</code>。</li>
</ul>
</li>
</ul>
<p>probe 可以理解为每个线程特有的哈希值（不同在于 probe 是可变的）与 counterCells.length - 1 的位与，目的是为了让每个线程都拥有属于自己的 counterCell，这样每个线程增加计数时就不会线程冲突了。由此可见 counterCells 本身就是一个小的哈希表，当 counterCells 为空或 counterCells[probe] 为空时，就需要 <code>fullAddCount(x, uncontended)</code> 来创建，此时 uncontended 为 true。</p>
<p>不幸的是，既然是哈希表，就存在哈希冲突。如果原子操作争用 counterCells[probe]（线程冲突），就需要 <code>fullAddCount(x, uncontended)</code> 解决哈希冲突和线程冲突，此时 uncontended 为 false。也就是说，这里的冲突包含两种含义：线程的哈希冲突和线程的竞争冲突。</p>
<h3 id="41-fulladdcount">4.1 fullAddCount<a class="anchor" href="#41-fulladdcount">#</a></h3>
<p><code>fullAddCount()</code> 可真是全能，来看看它是如何实现的。依旧，先理清框架，再探究细节。</p>
<pre><code class="language-java">private final void fullAddCount(long x, boolean wasUncontended) {
    int h;
    // 判断线程哈希值是否初始化
    if ((h = ThreadLocalRandom.getProbe()) == 0) {
        ThreadLocalRandom.localInit(); // force initialization
        h = ThreadLocalRandom.getProbe();
        wasUncontended = true; // 重新假设未发生争用
    }
    boolean collide = false; // 是否要给counterCells扩容的标志
    for (;;) {
        CounterCell[] as; CounterCell a; int n; long v;
        // 1.counterCells非空且长度大于0，用它来计数
        if ((as = counterCells) != null &amp;&amp; (n = as.length) &gt; 0) {
            ... // 详见4.2节
        }
        // 2.counterCells为空或长度为0，初始化counterCells
        else if (cellsBusy == 0 &amp;&amp; counterCells == as &amp;&amp;
                 U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
            // 获取cellsBusy锁
            boolean init = false;
            try { // Initialize table
                if (counterCells == as) {
                    CounterCell[] rs = new CounterCell[2]; // 初始长度为2
                    rs[h &amp; 1] = new CounterCell(x);
                    counterCells = rs;
                    init = true;
                }
            } finally {
                cellsBusy = 0;
            }
            if (init)
                break;
        }
        // 3.counterCells为空或长度为0，并且获取cellsBusy锁失败，则会再次尝试将x累加到baseCount
        else if (U.compareAndSwapLong(this, BASECOUNT, v = baseCount, v + x))
            break; // Fall back on using base
    } 
}
</code></pre>
<p>首先判断线程哈希值是否初始化，若未初始化，则通过 <code>ThreadLocalRandom.localInit()</code> 强制初始化。</p>
<p>魔术 0x9e3779b9 是黄金分割比与 2^32 的乘积，使用它能够有效分散哈希分布。</p>
<pre><code class="language-java">private static final int PROBE_INCREMENT = 0x9e3779b9; // 魔数
private static final AtomicInteger probeGenerator = new AtomicInteger(); // 竞争不激烈，可用原子类

static final void localInit() {
    int p = probeGenerator.addAndGet(PROBE_INCREMENT); // 每次累加魔数
    int probe = (p == 0) ? 1 : p; // skip 0
    long seed = mix64(seeder.getAndAdd(SEEDER_INCREMENT));
    Thread t = Thread.currentThread();
    UNSAFE.putLong(t, SEED, seed);
    UNSAFE.putInt(t, PROBE, probe); // 写回
}
</code></pre>
<p>初始化后，将 wasUncontended 置为 true，由于 probe 改变了，可以假设未发生争用。</p>
<p>接着是一个复杂的循环，但是总体框架是清晰的：</p>
<ol>
<li>counterCells 非空且长度大于 0：用它来计数；</li>
<li>counterCells 为空或长度为 0，初始化 counterCells；</li>
<li>counterCells 为空或长度为 0，并且获取 cellsBusy 锁失败：再次尝试将 x 累加到 baseCount。</li>
</ol>
<p>第二个和第三个分支比较好理解，关键在于第一个分支如何用 counterCells 计数，又是如何处理 counterCells 哈希冲突的。</p>
<h3 id="42-countercells">4.2 counterCells<a class="anchor" href="#42-countercells">#</a></h3>
<p>循环：</p>
<ol>
<li>若 counterCells[probe] 为空，插入新的 <em>CounterCell</em> 对象：
<ul>
<li>创建成功：已记录 x，跳出；</li>
<li>创建失败：进入下一个循环。</li>
</ul>
</li>
<li>若 wasUncontended 为 false，存在竞争：
<ul>
<li>wasUncontended 置为 true；</li>
<li>执行线程 rehash，进入下一个循环。</li>
</ul>
</li>
<li>若成功通过 CAS 将 x 累加进 counterCells[probe]：跳出。</li>
<li>若 counterCells 正在扩容或长度大于等于处理器数：
<ul>
<li>collide 置为 false，无法扩容；</li>
<li>执行线程 rehash，进入下一个循环。</li>
</ul>
</li>
<li>若 collide 为 false：
<ul>
<li>collide 置为 true，下一轮第三步继续失败将进行扩容；</li>
<li>执行线程 rehash，进入下一个循环。</li>
</ul>
</li>
<li>若 collide 为 true：
<ul>
<li>尝试给 counterCells 扩容；</li>
<li>进入下一个循环。</li>
</ul>
</li>
</ol>
<p>以上就是 counterCells 计数的流程，有几个点需要说明：</p>
<ul>
<li>就算进行了线程 rehash 也没法保证一定不会哈希冲突，但是如果传入值 wasUncontended 明确表示存在哈希冲突和线程冲突并存，第二步还是会主动线程 rehash。</li>
<li>第一步和第二步都只会执行一次，之后的每一次循环都会尝试第三步通过 CAS 将 x 累加进 counterCells[probe]。</li>
<li>并不是第三步失败，就立即扩容，两者之间还是会多次尝试第三步 CAS。</li>
<li>如果不能扩容，就会在第三步和第四步间来回执行，直到线程 rehash 后第三步 CAS 成功为止。</li>
</ul>
<pre><code class="language-java">if ((as = counterCells) != null &amp;&amp; (n = as.length) &gt; 0) {
	// 1.counterCells[probe]为空，插入新的CounterCell
    if ((a = as[(n - 1) &amp; h]) == null) {
        if (cellsBusy == 0) {            // Try to attach new Cell
            // 乐观地提前创建了value=x的CounterCell
            CounterCell r = new CounterCell(x); // Optimistic create
            if (cellsBusy == 0 &amp;&amp; // CAS获取cellsBusy锁
                U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
                boolean created = false;
                try { // Recheck under lock
                    CounterCell[] rs; int m, j;
                    // 判断有没有被其它线程初始化
                    if ((rs = counterCells) != null &amp;&amp;
                        (m = rs.length) &gt; 0 &amp;&amp;
                        rs[j = (m - 1) &amp; h] == null) {
                        rs[j] = r;
                        created = true;
                    }
                } finally {
                    cellsBusy = 0; // 释放cellsBusy锁，赋值本身具有原子性
                }
                if (created) // 初始化元素成功，直接退出循环
                    break;
                continue; // Slot is now non-empty
            }
        }
        collide = false;
    }
    // 2.wasUncontended为false，存在竞争，线程rehash
    else if (!wasUncontended)       // CAS already known to fail
        wasUncontended = true;      // Continue after rehash（指的是更改当前线程的哈希值）
    // 3.尝试将x累加进数组元素
    else if (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))
        break;
    // 4.判断counterCells是否正在扩容，或数组长度是否大于等于处理器数
    else if (counterCells != as || n &gt;= NCPU)
        collide = false;            // At max size or stale
    // 5.如果数组没有在扩容，且数组长度小于处理器数
    // 此时，如果collide为false，则把它变成true
    // 在下一轮循环中，如果CAS累加value继续失败，就会触发counterCells扩容
    else if (!collide)
        collide = true;
    // 6.如果collide为true，则尝试给counterCells数组扩容
    else if (cellsBusy == 0 &amp;&amp;
             U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
        try {
            if (counterCells == as) {// Expand table unless stale
                CounterCell[] rs = new CounterCell[n &lt;&lt; 1];
                for (int i = 0; i &lt; n; ++i)
                    rs[i] = as[i];
                counterCells = rs;
            }
        } finally {
            cellsBusy = 0;
        }
        collide = false;
        continue; // Retry with expanded table
    }
    // 更改当前线程的哈希值，未continue得分支都会执行
    h = ThreadLocalRandom.advanceProbe(h); 
}
</code></pre>
<h2 id="五读取">五、读取<a class="anchor" href="#五读取">#</a></h2>
<p>既然采用了 COW 的思想，读取总是比写入简单得多。</p>
<pre><code class="language-java">    public V get(Object key) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;
        int h = spread(key.hashCode());
        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
            (e = tabAt(tab, (n - 1) &amp; h)) != null) {
            // 首节点即匹配
            if ((eh = e.hash) == h) {
                if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))
                    return e.val;
            }
            // 该桶已经被迁移，则交由节点find()方法查找
            else if (eh &lt; 0)
                return (p = e.find(h, key)) != null ? p.val : null;
            // 搜索桶内所有节点
            while ((e = e.next) != null) {
                if (e.hash == h &amp;&amp;
                    ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))
                    return e.val;
            }
        }
        return null;
    }
</code></pre>
<p>当搜索的桶已经迁移时，会得到一个 <em>ForwardingNode</em> 类节点，通过 <code>find()</code> 就可以追踪到迁移后的桶（nextTable[(n - 1) &amp; h]，n=nextTable.length，h=key.hash），然后在该桶内查找。</p>
<pre><code class="language-java">Node&lt;K,V&gt; find(int h, Object k) {
    // loop to avoid arbitrarily deep recursion on forwarding nodes
    outer: for (Node&lt;K,V&gt;[] tab = nextTable;;) {
        Node&lt;K,V&gt; e; int n;
        if (k == null || tab == null || (n = tab.length) == 0 ||
            (e = tabAt(tab, (n - 1) &amp; h)) == null)
            return null;
        for (;;) {
            int eh; K ek;
            if ((eh = e.hash) == h &amp;&amp;
                ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))
                return e;
            if (eh &lt; 0) {
                if (e instanceof ForwardingNode) {
                    tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;
                    continue outer;
                }
                else
                    return e.find(h, k);
            }
            if ((e = e.next) == null)
                return null;
        }
    }
}
</code></pre>
<h2 id="参考">参考<a class="anchor" href="#参考">#</a></h2>
<ol>
<li><a href="https://www.cnblogs.com/zerotomax/p/8687425.html#go7" 
  
   target="_blank" rel="noreferrer noopener" 
>ConcurrentHashMap 1.8 源码分析</a>
</li>
<li><a href="https://blog.csdn.net/Unknownfuture/article/details/105350537" 
  
   target="_blank" rel="noreferrer noopener" 
>sizeCtl 含义的辨析</a>
</li>
<li><a href="https://stackoverflow.com/questions/61722136/java-concurrenthashmap-initialization" 
  
   target="_blank" rel="noreferrer noopener" 
>initTable 的问题</a>
</li>
<li><a href="https://stackoverflow.com/questions/63651473/java-concurrent-hashmap-inittable-why-the-try-finally-block" 
  
   target="_blank" rel="noreferrer noopener" 
>Java Concurrent Hashmap initTable() Why the try/finally block?</a>
</li>
<li><a href="https://stackoverflow.com/questions/47175835/how-does-concurrenthashmap-resizestamp-method-work" 
  
   target="_blank" rel="noreferrer noopener" 
>How does ConcurrentHashMap resizeStamp method work?</a>
</li>
<li><a href="https://stackoverflow.com/questions/53493706/how-the-conditions-sc-rs-1-sc-rs-max-resizers-can-be-achieved-in" 
  
   target="_blank" rel="noreferrer noopener" 
>关于 sc == rs + 1 || sc == rs + MAX_RESIZERS</a>
</li>
<li><a href="https://www.jianshu.com/p/971ee45597ac" 
  
   target="_blank" rel="noreferrer noopener" 
>ConcurrentHashMap 1.8 计算 size 的方式</a>
</li>
<li><a href="https://www.jianshu.com/p/c3c108c3dcfd" 
  
   target="_blank" rel="noreferrer noopener" 
>伪共享</a>
</li>
</ol>


              
          </article>
          

<ul class="tags__list">
    
    <li class="tag__item">
        <a class="tag__link" href="https://lil-q.github.io/tags/java/">java</a>
    </li>
    <li class="tag__item">
        <a class="tag__link" href="https://lil-q.github.io/tags/concurrency/">concurrency</a>
    </li>
    <li class="tag__item">
        <a class="tag__link" href="https://lil-q.github.io/tags/source_code/">source_code</a>
    </li></ul>

 <div class="pagination">
  
    <a class="pagination__item" href="https://lil-q.github.io/blog/copyonwritearraylist/">
        <span class="pagination__label">Previous Post</span>
        <span class="pagination__title">Java 并发：CopyOnWriteArrayList</span>
    </a>
  

  
</div>

          
          <footer class="post__footer">
            


<div class="social-icons">
  
     
    
  
     
    
      <a class="social-icons__link" rel="me" title="GitHub"
         href="https://github.com/lil-q"
         target="_blank" rel="noopener">
        <div class="social-icons__icon" style="background-image: url('https://lil-q.github.io/svg/github.svg')"></div>
      </a>
    
  
     
    
      <a class="social-icons__link" rel="me" title="Email"
         href="mailto:qitiantianc137@outlook.com"
         target="_blank" rel="noopener">
        <div class="social-icons__icon" style="background-image: url('https://lil-q.github.io/svg/email.svg')"></div>
      </a>
    
     
</div>

            <p>2019-2021 © lil-q</p>
          </footer>
          </div>
      </div>
      
      <div class="toc-container">
          
        <nav id="TableOfContents">
  <ul>
    <li><a href="#一初始化">一、初始化</a></li>
    <li><a href="#二写入">二、写入</a>
      <ul>
        <li><a href="#21-inittable">2.1 initTable</a></li>
        <li><a href="#22-treeifybin">2.2 treeifyBin</a></li>
        <li><a href="#23-addcount">2.3 addCount</a></li>
      </ul>
    </li>
    <li><a href="#三扩容">三、扩容</a>
      <ul>
        <li><a href="#31-p-扩容">3.1 P 扩容</a></li>
        <li><a href="#32-c-扩容">3.2 C 扩容</a></li>
        <li><a href="#33-transfer">3.3 transfer</a></li>
      </ul>
    </li>
    <li><a href="#四计数">四、计数</a>
      <ul>
        <li><a href="#41-fulladdcount">4.1 fullAddCount</a></li>
        <li><a href="#42-countercells">4.2 counterCells</a></li>
      </ul>
    </li>
    <li><a href="#五读取">五、读取</a></li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
      </div>
      
    </div>
    

  </main>

   

  
  <script src="/js/index.min.49e4d8a384357d9b445b87371863419937ede9fa77737522ffb633073aebfa44.js" integrity="sha256-SeTYo4Q1fZtEW4c3GGNBmTft6fp3c3Ui/7YzBzrr&#43;kQ=" crossorigin="anonymous"></script>
  
  
  <script src="https://unpkg.com/prismjs@1.20.0/components/prism-core.min.js"></script>

  
  <script src="https://unpkg.com/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js"
    data-autoloader-path="https://unpkg.com/prismjs@1.20.0/components/"></script>

  
    <script src="/js/table-of-contents.js"></script>
  


</body>

</html>
