<!DOCTYPE html>
<html lang="en-us">

<head>
  <title>面向对象 | Homeward</title>

  <meta charset="UTF-8">
  <meta name="language" content="en">
  <meta name="description" content="面向对象">
  <meta name="keywords" content="面向对象 , OOP">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  
  

  <link rel="shortcut icon" type="image/png" href="/favicon.ico" />

  
  
    
 
  
  
  
  
  
  
    
    <link type="text/css" rel="stylesheet" href="/css/post.min.ab05d5e01a9242c9472ee834dca8b5e136420f575e85e4d6d45b56022054489f.css" integrity="sha256-qwXV4BqSQslHLug03Ki14TZCD1deheTW1FtWAiBUSJ8="/>
  
    
    <link type="text/css" rel="stylesheet" href="/css/custom.min.90b5007688d9661bb8a3c179e17156ae3f54efa01088ed1cd0364235af826683.css" integrity="sha256-kLUAdojZZhu4o8F54XFWrj9U76AQiO0c0DZCNa&#43;CZoM="/>
  
  
   
   
    

<script type="application/ld+json">
  
    {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/lil-q.github.io\/"
      },
      "articleSection" : "blog",
      "name" : "面向对象",
      "headline" : "面向对象",
      "description" : "面向对象",
      "inLanguage" : "en-US",
      "author" : "",
      "creator" : "",
      "publisher": "",
      "accountablePerson" : "",
      "copyrightHolder" : "",
      "copyrightYear" : "2020",
      "datePublished": "2020-09-07 18:54:03 \u002b0800 CST",
      "dateModified" : "2020-09-07 18:54:03 \u002b0800 CST",
      "url" : "https:\/\/lil-q.github.io\/blog\/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1\/",
      "wordCount" : "321",
      "keywords" : ["面向对象", "OOP", "Blog"]
    }
  
  </script>
</head>

<body>
  <div class="burger__container">
  <div class="burger" aria-controls="navigation" aria-label="Menu">
    <div class="burger__meat burger__meat--1"></div>
    <div class="burger__meat burger__meat--2"></div>
    <div class="burger__meat burger__meat--3"></div>
  </div>
</div>
 

  <nav class="nav" id="navigation">
  <ul class="nav__list">
    
    
      <li>
        <a  href="/">About</a>
      </li>
    
      <li>
        <a  class="active"
         href="/blog">技术</a>
      </li>
    
      <li>
        <a  href="/picture">相册</a>
      </li>
    
      <li>
        <a  href="/essay">随笔</a>
      </li>
    
  </ul>
</nav>


  <main>
    
    

    <div class="flex-wrapper">
      <div class="post__container">
        <div class="post">
          <header class="post__header">
            <h1 id="post__title">面向对象</h1>
            <time datetime="2020-09-07 18:54:03 &#43;0800 CST" class="post__date">Sep 7 2020</time> 
          </header>
          <article class="post__content">
              
<p><strong>面向对象程序设计</strong>（<strong>O</strong>bject-<strong>O</strong>riented <strong>P</strong>rogramming，<strong>OOP</strong>）是一种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的资料。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。</p>
<h2 id="一特性">一、特性<a class="anchor" href="#一特性">#</a></h2>
<h3 id="11-封装">1.1 封装<a class="anchor" href="#11-封装">#</a></h3>
<p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p>
<p>优点：</p>
<ul>
<li>减少耦合：可以独立地开发、测试、优化、使用、理解和修改；</li>
<li>减轻维护的负担：可以更容易被理解，并且在调试的时候可以不影响其他模块；</li>
<li>有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能；</li>
<li>提高软件的可重用性；</li>
<li>降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的。</li>
</ul>
<h3 id="12-继承">1.2 继承<a class="anchor" href="#12-继承">#</a></h3>
<p>继承是指在某种情况下，一个类会有子类。子类比原本的类（称为父类）要更加具体化。java 只允许单继承，一个子类只能继承自一个父类，使用<code>extends</code>关键字。也就是说对于一个类，只能认为它属于另一个大类，如果它需要实现其他功能时，则还要实现功能接口（interface），使用<code>implements</code>关键字。</p>
<h3 id="13-多态">1.3 多态<a class="anchor" href="#13-多态">#</a></h3>
<p>C++ 中的虚函数就是为了多态。Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是 Java 的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。</p>
<p>方法的重写（Override）和重载（Overload）是 java 多态性的不同表现。重写解决的是子类与父类针对同一方法需要采取不同实现方式的问题，通过 JVM 在类加载时（解析阶段）的动态绑定机制实现。重载是面向使用者的，针对不同的调用方式返回不同的结果。</p>
<h2 id="二设计原则">二、设计原则<a class="anchor" href="#二设计原则">#</a></h2>
<p>错误的设计类会带来很多问题，比如下面的悖论（为了方便理解，下文中长方形指代长宽不等的矩形）。</p>
<h3 id="21-正方形不是矩形">2.1 正方形不是矩形？<a class="anchor" href="#21-正方形不是矩形">#</a></h3>
<p>首先写出矩形类，定义长和宽，并写出长宽的 <em>setter</em> 方法和一个获取面积的方法：</p>
<pre><code class="language-java">public class Rectangle {
    int length;
    int width;

    public void setLength(int length) {
        this.length = length;
    }

    public void setWidth(int width) {
        this.width = width;
    }

    public int getArea() {
        return length * width;
    }
}
</code></pre>
<p>写出子类正方形，由于正方形的长宽是相同的，重写两个 <em>setter</em> 方法保证长宽一致：</p>
<pre><code class="language-java">class Square extends Rectangle {

    public void setLength(int length) {
        this.length = length;
        this.width = length;
    }

    public void setWidth(int width) {
        this.width = width;
        this.length = width;
    }
}
</code></pre>
<p>最后我们生产一个正方形，并且指派一个矩形质检员来负责检查这个正方形是否合格。质检员把长设为 4，宽设为 3，检查最后得到的面积是否为 12：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        Square square = new Square();
        System.out.println(test(square)); // false
    }

    public static boolean test(Rectangle rectangle) {
        rectangle.setLength(4);
        rectangle.setWidth(3);
        return rectangle.getArea() == 4 * 3; // Oops... 9 != 12
    }
}
</code></pre>
<p>问题出现了，矩形质检员并不知道这是一个正方形，他使用传统的质检矩形的方法来检查竟然发现这个正方形连矩形也不是，难道正方形不是矩形？</p>
<h3 id="22-solid">2.2 S.O.L.I.D<a class="anchor" href="#22-solid">#</a></h3>
<p>要解决上面的问题，首先要对面向对象的设计原则有所了解：</p>
<table>
<thead>
<tr>
<th align="center">首字母</th>
<th align="center">指代</th>
<th align="center">概念</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">S</td>
<td align="center">单一功能原则</td>
<td align="center">对象应该仅具有一种单一功能</td>
</tr>
<tr>
<td align="center">O</td>
<td align="center">开闭原则</td>
<td align="center">软件应该对于扩展开放，对于修改封闭</td>
</tr>
<tr>
<td align="center">L</td>
<td align="center">里氏替换原则</td>
<td align="center">程序中的对象应该可以在不改变程序正确性的前提下被它的子类所替换</td>
</tr>
<tr>
<td align="center">I</td>
<td align="center">接口隔离原则</td>
<td align="center">多个特定客户端接口要好于一个宽泛用途的接口</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">依赖反转原则</td>
<td align="center">方法应该遵从依赖于抽象而不是一个实例</td>
</tr>
</tbody>
</table>
<p>首先，正方形和长方形需要实现多态，而矩形这个类同时包含了这两个语义，相互耦合，模糊不清，违反了单一功能原则。其次，对于矩形而言，长宽是根本属性，也正是长宽的关系决定了矩形是正方形还是长方形。对根本属性不应该设置 <em>setter</em> 方法，这违反了开闭原则。最后，子类正方形不能够替代父类矩形使用，违反了里氏替换原则。如果继承的目的是为了多态，而多态的前提就是子类覆盖并重新定义父类的方法，为了符合 LSP，我们应该将父类定义为抽象类，并定义抽象方法，让子类重新定义这些方法。当父类是抽象类时，父类就不能实例化，避免了子类替换父类实例（根本不存在父类实例）时的逻辑不一致<a href="https://www.zhihu.com/question/27191817">[2]</a>。</p>
<h3 id="23-正方形是抽象矩形">2.3 正方形是抽象矩形<a class="anchor" href="#23-正方形是抽象矩形">#</a></h3>
<p>怎样才能打破正方形不是矩形的悖论呢？</p>
<blockquote>
<p><strong>Abstraction is the Key.</strong></p>
</blockquote>
<p>重写抽象矩形类作为父类，并实现封闭图形接口，这个接口的功能是求面积，抽象矩形下定义两个抽象方法，分别用来获取长和宽：</p>
<pre><code class="language-java">interface ClosedFigure {

    int getArea();
}

abstract class AbstractRectangle implements ClosedFigure {

    abstract int getLength();

    abstract int getWidth();
}
</code></pre>
<p>长方形类和正方形类作为子类继承抽象矩形类。对于长方形，定义两个 <em>final</em>  修饰的字段表示长宽，对于正方形，定义一个 <em>final</em> 修饰的字段表示边长，这是为了保证特征属性的不可变。分别重写父类的两个抽象方法和接口的一个抽象方法：</p>
<pre><code class="language-java">class Rectangle extends AbstractRectangle implements ClosedFigure {
    private final int length;
    private final int width;

    Rectangle(int length, int width) {
        this.length = length;
        this.width = width;
    }

    @Override
    int getLength() {
        return length;
    }

    @Override
    int getWidth() {
        return width;
    }

    @Override
    public int getArea() {
        return length * width;
    }
}

class Square extends AbstractRectangle implements ClosedFigure {
    private final int sideLength;

    Square(int sideLength) {
        this.sideLength = sideLength;
    }

    @Override
    int getLength() {
        return sideLength;
    }

    @Override
    int getWidth() {
        return sideLength;
    }

    @Override
    public int getArea() {
        return sideLength * sideLength;
    }
    
    // 追加功能，获取边长
    int getSideLength() {
        return sideLength;
    }
}
</code></pre>
<p>问题解决了，以前总是不明白抽象类和接口同时存在的意义，现在终于意识到抽象类是那么重要！</p>
<h2 id="参考">参考<a class="anchor" href="#参考">#</a></h2>
<ol>
<li><a href="https://cyc2018.github.io/CS-Notes/#/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3">cyc CS-Notes</a></li>
<li><a href="https://www.zhihu.com/question/27191817">JAVA中，多态是不是违背了里氏替换原则？</a></li>
<li><a href="https://www.cnblogs.com/gaochundong/p/open_closed_principle.html">开放封闭原则</a></li>
</ol>


              
          </article>
          

<ul class="tags__list">
    
    <li class="tag__item">
        <a class="tag__link" href="https://lil-q.github.io/tags/basis/">basis</a>
    </li></ul>

 <div class="pagination">
  
    <a class="pagination__item" href="https://lil-q.github.io/blog/http-restful/">
        <span class="pagination__label">Previous Post</span>
        <span class="pagination__title">HTTP &amp; RESTful</span>
    </a>
  

  
</div>

          
          <footer class="post__footer">
            


<div class="social-icons">
  
     
    
  
     
    
      <a class="social-icons__link" title="GitHub"
         href="https://github.com/lil-q"
         target="_blank" rel="noopener">
        <div class="social-icons__icon" style="background-image: url('https://lil-q.github.io/svg/github.svg')"></div>
      </a>
    
  
     
    
      <a class="social-icons__link" title="Email"
         href="mailto:qitiantianc137@outlook.com"
         target="_blank" rel="noopener">
        <div class="social-icons__icon" style="background-image: url('https://lil-q.github.io/svg/email.svg')"></div>
      </a>
    
     
</div>

            <p>2020 © lil-q</p>
          </footer>
          </div>
      </div>
      
      <div class="toc-container">
          
        <nav id="TableOfContents">
  <ul>
    <li><a href="#一特性">一、特性</a>
      <ul>
        <li><a href="#11-封装">1.1 封装</a></li>
        <li><a href="#12-继承">1.2 继承</a></li>
        <li><a href="#13-多态">1.3 多态</a></li>
      </ul>
    </li>
    <li><a href="#二设计原则">二、设计原则</a>
      <ul>
        <li><a href="#21-正方形不是矩形">2.1 正方形不是矩形？</a></li>
        <li><a href="#22-solid">2.2 S.O.L.I.D</a></li>
        <li><a href="#23-正方形是抽象矩形">2.3 正方形是抽象矩形</a></li>
      </ul>
    </li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
      </div>
      
    </div>
    

  </main>

   

  
  <script src="/js/index.min.49e4d8a384357d9b445b87371863419937ede9fa77737522ffb633073aebfa44.js" integrity="sha256-SeTYo4Q1fZtEW4c3GGNBmTft6fp3c3Ui/7YzBzrr&#43;kQ=" crossorigin="anonymous"></script>
  
  
  <script src="https://unpkg.com/prismjs@1.20.0/components/prism-core.min.js"></script>

  
  <script src="https://unpkg.com/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js"
    data-autoloader-path="https://unpkg.com/prismjs@1.20.0/components/"></script>

  
    <script src="/js/table-of-contents.js"></script>
  


</body>

</html>
