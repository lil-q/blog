<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on Homeward</title>
    <link>https://lil-q.github.io/blog/</link>
    <description>Recent content in Blogs on Homeward</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© {year}</copyright>
    <lastBuildDate>Tue, 07 Jul 2020 11:17:47 +0000</lastBuildDate>
    
	<atom:link href="https://lil-q.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>java-虚拟机</title>
      <link>https://lil-q.github.io/blog/java-%E8%99%9A%E6%8B%9F%E6%9C%BA/</link>
      <pubDate>Tue, 07 Jul 2020 11:17:47 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java-%E8%99%9A%E6%8B%9F%E6%9C%BA/</guid>
      <description>一、内存区域 1.1 程序计数器 程序计数器是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都依赖这个计数器。记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。
1.2 Java 虚拟机栈 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
该区域可能抛出以下异常：
 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常； 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。  1.3 本地方法栈 本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。
本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。
1.4 堆 所有对象都在这里分配内存，是垃圾收集的主要区域（&amp;ldquo;GC 堆&amp;rdquo;）。
现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：
 新生代（Young Generation） 老年代（Old Generation）  堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。
栈和堆的区别如下：
 功能：栈的功能是运行，堆的功能是储存； 共享性：栈是线程隔离的，堆是线程共享的； 异常错误 ：栈可能出 StackOverflowError 异常和 OutOfMemoryError 异常，堆出后者； 空间：栈的空间连续，堆的空间不连续，栈的空间远小于堆。  1.5 方法区 用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。
对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。
HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</description>
    </item>
    
    <item>
      <title>操作系统</title>
      <link>https://lil-q.github.io/blog/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Sun, 10 May 2020 00:08:33 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
      <description>&lt;p&gt;操作系统是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>计算机网络</title>
      <link>https://lil-q.github.io/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Tue, 05 May 2020 19:30:17 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</guid>
      <description>网络把主机连接起来，而互连网（internet）是把多种不同的网络连接起来，因此互连网是网络的网络。
一、概述 1.1 主机之间的通信方式   客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。
  对等（P2P）：不区分客户和服务器。
  1.2 报文交换  电路交换：整个报文的比特流连续地从源点直达终点，好像在一个管道中传送一样。 报文交换：整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。 分组交换：单个分组（如p1，整个报文的一部分）传送到相邻结点，存储下来后查找转发表，转达到下一个结点。  1.3 时延 总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延
1. 排队时延 分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。
2. 处理时延 主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。
3. 传输时延 主机或路由器传输数据帧所需要的时间。
4. 传播时延 电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。
1.4 体系结构  应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。 传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。 网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。 数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。  1. 协议 为进行网络中的数据交换而建立的规则、标准或约定称为网络协议。
其中表示层和会话层用途如下：
 表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。 会话层 ：建立及管理会话。  五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处。</description>
    </item>
    
    <item>
      <title>morris算法</title>
      <link>https://lil-q.github.io/blog/morris%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 01 May 2020 14:51:08 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/morris%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;p&gt;morris 遍历利用的是树的叶节点左右孩子为空（树的大量空闲指针），实现空间开销的极限缩减。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>java-并发</title>
      <link>https://lil-q.github.io/blog/java-%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Tue, 28 Apr 2020 19:37:01 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java-%E5%B9%B6%E5%8F%91/</guid>
      <description>计算机的运算速度与它的存储和通信子系统的速度差距太大，大量的时间都花费在磁盘 I/O、网络通信或者数据库访问上。高效并发能能更好的利用计算机的性能。另一方面，一个服务器要同时对多个客户端提供服务。衡量一个服务性能的高低好坏，每秒事务处理数（Transaction Per Second，TPS）是重要的指标之一，其与程序的并发能力有着密切关系。题解
一、硬件的效率和一致性 由于计算机的存储设备与处理器的运算速度有着几个数量级的差距，所以现代计算机系统都不得不加入一层或多层读写速度尽可能接近处理器运算速度的**高速缓存（ Cache）**来作为内存与处理器之间的缓冲：将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。
基于高速缓存的存储交互很好地解决了处理器与内存速度之间的矛盾，但是也为计算机系统带来更高的复杂度，它引入了一个新的问题：缓存一致性（ Cache Coherence）。在多路处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（ Main Memory），这种系统称为共享内存多核系统（ Shared Memory Multiprocessors System），如下图所示。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。
为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作。
除了増加高速缓存之外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java 虚拟机的即时编译器中也有指令重排序（ Instruction Reorder）优化。
二、Java 内存模型 Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。
 此处的变量（Variables）与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。
 Java内存模型规定了所有的变量都存储在主内存（ Main Memory，与硬件的主内存同名，但物理上它仅是虚拟机内存的一部分）。每条线程还有自己的工作内存（ Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成（如果局部变量是一个 reference 类型，它引用的对象在Java堆中可被各个线程共享，但是 reference 本身在 Java 栈的局部变量表中是线程私有的）。
2.1 内存间交互操作 Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于 double和long类型的变量来说， load、 store、read 和 write 操作在某些平台r上允许有例外）。
 lock：作用于主内存的变量，标识为一条线程独占。 unlock：作用于主内存的变量，释放处于锁定状态的变量。 read：作用于主内存的变量，传输到工作内存中。 load：作用于工作内存的变量，在 read 之后执行，把值放入工作内存的变量副本中。 use：作用于工作内存的变量，传递给执行引擎。 assign：作用于工作内存的变量，把一个从执行引擎接收到的值赋给工作内存的变量。 store：作用于工作内存的变量，把一个变量的值传送到主内存中。 write：作用于主内存的变量，在 store 之后执行，把值放入主内存的变量中。  2.2 volatile 关键字 volatile 可以说是Java虚拟机提供的最轻量级的同步机制，它将具备两项特性：一是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。二是禁止指令重排序优化，有 volatile 修饰的变量，赋值后多执行了一个内存屏障操作，指重排序时不能把后面的指令重排序到内存屏障之前的位置。</description>
    </item>
    
    <item>
      <title>java-I/O</title>
      <link>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E5%85%AD/</link>
      <pubDate>Sat, 04 Apr 2020 14:13:57 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E5%85%AD/</guid>
      <description>一、IO 1.1 File  创建File f = new File(&amp;quot;C:\\Windiws\\...&amp;quot;)对象本身不涉及IO操作，并不会导致任何磁盘操作； 可以获取路径／绝对路径／规范路径：getPath()/getAbsolutePath()/getCanonicalPath()； 可以获取目录的文件和子目录：list()/listFiles()； boolean mkdir()：创建当前File对象表示的目录； boolean mkdirs()：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来； boolean delete()：删除当前File对象表示的目录，当前目录必须为空才能删除成功。  Java I/O 使用了装饰者模式来实现。以 InputStream 为例，
 InputStream 是抽象组件； FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作； FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。  实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。
1.2 输入 InputStream就是Java标准库提供的最基本的输入流。它位于java.io这个包里。java.io包提供了所有同步IO的功能。
InputStream并不是一个接口，而是一个抽象类，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是int read()：
public abstract int read() throws IOException;  这个方法会读取输入流的下一个字节，并返回字节表示的int值（0~255）。如果已读到末尾，返回-1表示不能继续读取了。
FileInputStream是InputStream的一个子类，能从文件流中读取数据。使用try(resource)可以保证InputStream正确关闭（因为InputStream和OutputStream都实现了java.lang.AutoCloseable接口）。
public void readFile() throws IOException { try (InputStream input = new FileInputStream(&amp;quot;src/readme.txt&amp;quot;)) { int n; while ((n = input.</description>
    </item>
    
    <item>
      <title>java-Map</title>
      <link>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E4%BA%94/</link>
      <pubDate>Thu, 02 Apr 2020 15:37:30 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E4%BA%94/</guid>
      <description>一、Map Map是一种键-值映射表，当我们调用put(K key, V value)方法时，就把key和value做了映射并放入Map。当我们调用V get(K key)时，就可以通过key获取到对应的value。如果key不存在，则返回null。和List类似，Map也是一个接口，最常用的实现类是HashMap。
 TreeMap：基于红黑树实现。 HashMap：基于哈希表实现。 HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。  1.1 Map遍历 要遍历key可以使用for each循环遍历Map实例的keySet()方法返回的Set集合，它包含不重复的key的集合：
for (String key : map.keySet()) {...}  同时遍历key和value可以使用for each循环遍历Map对象的entrySet()集合，它包含每一个key-value映射：
for (Map.Entry&amp;lt;String, Integer&amp;gt; entry : map.entrySet()) {...}  1.2 equals() &amp;amp; hashCode() 正确使用Map必须保证：
 作为key的对象必须正确覆写equals()方法，相等的两个key实例调用equals()必须返回true； 作为key的对象还必须正确覆写hashCode()方法，且hashCode()方法要严格遵循以下规范：  如果两个对象相等，则两个对象的hashCode()必须相等； 如果两个对象不相等，则两个对象的hashCode()尽量不要相等。    自己写hashCode()时R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：31*x == (x&amp;lt;&amp;lt;5)-x，编译器会自动进行这个优化。
@Override public int hashCode() { int result = 17; result = 31 * result + x; result = 31 * result + y; result = 31 * result + z; return result; }  和实现equals()方法遇到的问题类似，如果firstName或lastName为null，上述代码工作起来就会抛NullPointerException。为了解决这个问题，我们在计算hashCode()的时候，经常借助Objects.</description>
    </item>
    
    <item>
      <title>java-Collection</title>
      <link>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E5%9B%9B/</link>
      <pubDate>Mon, 30 Mar 2020 18:34:55 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E5%9B%9B/</guid>
      <description>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。
 源码基于java 13。
 一、Collection 二、List List接口，可以看到几个主要的接口方法：
 在末尾添加一个元素：void add(E e) 在指定索引添加一个元素：void add(int index, E e) 删除指定索引的元素：int remove(int index) 删除某个元素：int remove(Object e) 获取指定索引的元素：E get(int index) 获取链表大小（包含元素的个数）：int size()  List接口允许我们添加重复的元素，即List内部的元素可以重复，List还允许添加null。调用List.of()，它返回的是一个只读List：
List&amp;lt;Integer&amp;gt; list = List.of(1, 2, 5);  但是List.of()方法不接受null值，如果传入null，会抛出NullPointerException异常。
2.1 List遍历 List的遍历采用了迭代器的设计模式：
Iterable接口声明如下：
public interface Iterable&amp;lt;T&amp;gt; { Iterator&amp;lt;T&amp;gt; iterator(); }  Iterator接口声明如下：
public interface Iterator&amp;lt;E&amp;gt; { // 判断是否还有下一个对象，如果有，则返回true，否则false boolean hasNext(); // 返回集合的下个值，此方法只能在hasNext方法返回true时调用 E next(); // 删除集合的当前值，此方法也只能在hasNext方法返回true时调用 void remove(); }  ListIterator接口声明如下：</description>
    </item>
    
    <item>
      <title>java-反射和泛型</title>
      <link>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E4%B8%89/</link>
      <pubDate>Fri, 27 Mar 2020 22:45:02 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E4%B8%89/</guid>
      <description>一、反射 由于 JVM 为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息。这种通过Class实例获取class信息的方法称为反射（Reflection）。
Java 反射主要提供以下功能：
 在运行时判断任意一个对象所属的类； 在运行时构造任意一个类的对象； 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）； 在运行时调用任意一个对象的方法。  重点：是运行时而不是编译时。
1.1 Class类 获取一个class的Class实例有三个方法：
方法一：直接通过一个class的静态变量class获取：
Class&amp;lt;?&amp;gt; cls = String.class;  方法二：如果我们有一个实例变量，可以通过该实例变量提供的getClass()方法获取：
String s = &amp;quot;Hello&amp;quot;; Class&amp;lt;?&amp;gt; cls = s.getClass();  方法三：如果知道一个class的完整类名，可以通过静态方法Class.forName()获取：
Class&amp;lt;?&amp;gt; cls = Class.forName(&amp;quot;java.lang.String&amp;quot;);  Class.forName()加载类时默认会初始化，而ClassLoader.loadClass()默认不会初始化，只完成了类加载中的第一步加载。
注意Class实例==比较和instanceof的差别：
Integer n = new Integer(123); boolean b1 = n instanceof Integer; // true，因为n是Integer类型 boolean b2 = n instanceof Number; // true，因为n是Number类型的子类 boolean b3 = n.getClass() == Integer.class; // true，因为n.getClass()返回Integer.class boolean b4 = n.</description>
    </item>
    
    <item>
      <title>java-面向对象和异常处理</title>
      <link>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E4%BA%8C/</link>
      <pubDate>Mon, 23 Mar 2020 14:08:20 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E4%BA%8C/</guid>
      <description>一、面向对象 Java是一种面向对象的编程语言。面向对象编程，英文是Object-Oriented Programming，简称OOP。
1.1 权限修饰符     本类 同一个包下（子类和无关类） 不同包下（子类） 不同包下（无关类）     private Y      default Y Y     protected Y Y Y    public Y Y Y Y    一个.java文件只能包含一个public类，但可以包含多个非public类。如果有public类，文件名必须和public类的名字相同。
1.2 继承 如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法。
子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。
 **向上转型（upcasting）：**一个子类类型安全地变为父类类型的赋值。向上转型只能够调用子类重写的方法。 **向下转型（downcasting）：**一个父类类型强制转型为子类类型。找回向上转型时丢失的子类扩展方法。  instanceof判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为null，那么对任何instanceof的判断都为false。
利用instanceof，在向下转型前可以先判断：
Person p = new Student(); if (p instanceof Student) { // 只有判断成功才会向下转型: Student s = (Student) p; // 一定会成功 }  从Java 14开始，判断instanceof后，可以直接转型为指定变量，避免再次强制转型。</description>
    </item>
    
    <item>
      <title>java-基础</title>
      <link>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Fri, 20 Mar 2020 19:33:14 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80/</guid>
      <description>JVM–java virtual machine JVM 是整个 java 实现跨平台的最核心的部分，所有的 java 程序会首先被编译为 .class 的类文件，这种类文件可以在虚拟机上执行，也就是说 class 并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。 JRE – java runtime environment JRE 是指 java 运行环境。在 JDK 的安装目录里你可以找到 jre 目录，里面有两个文件夹 bin 和 lib ，在这里可以认为 bin 里的就是 jvm，lib 中则是 jvm 工作所需要的类库，而 bin 和 lib 和起来就称为 JRE。 JDK – java development kit JDK 是 java 开发工具包，是支持 java 程序开发的最小环境。JDK 对比 JRE 多了 java language 和工具 API。  一、数据类型 1.1 基本类型  byte/8 [-128 ~ 127] char/16 short/16 [-32768 ~ 32767] int/32 [-2147483648 ~ 2147483647] float/32 long/64 [-9223372036854775808 ~ 9223372036854775807] double/64 boolean/~  Java语言对布尔类型的存储并没有做规定，因为理论上存储布尔类型只需要1 bit，但是通常JVM内部会把boolean表示为4字节整数，为了节省内存而表示为更小的类型可能会在之后处理时带来不必要的麻烦。</description>
    </item>
    
    <item>
      <title>OpenCV-python-5</title>
      <link>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/</link>
      <pubDate>Sat, 22 Feb 2020 17:51:07 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/</guid>
      <description>一、图像梯度 在谈及梯度之前需要先找到函数，图片是二维的离散函数，二维意味着需要找到求梯度的方向，离散意味着对于图片的梯度不是导数而是差分。下式就是按照水平从左到右方向每隔一个像素点求差分：
$$ \Delta f\left ( i,j \right )=f\left ( i+1,j \right )-f\left ( i,j \right ) $$
1.1 Prewitt operator 将上式用卷积的方式处理是就可以是有下面这个卷积核（Prewitt 边缘检测算子）：
$$ Prewitt = \frac{1}{9}\left[ \begin{matrix} -1 &amp;amp; 0 &amp;amp; 1 \newline -1 &amp;amp; 0 &amp;amp; 1 \newline -1 &amp;amp; 0 &amp;amp; 1 \end{matrix} \right] $$
使用 Prewitt 算子处理后，值比较高的像素点意味着梯度较大，就是更解决边缘；值比较低的像素点意味着梯度较小，就是更解决平滑表面。
1.2 Sobel operator 考虑到对正在处理行的数据需要更多的重视，对 Prewitt 边缘检测算子改进就形成了 Sobel 边缘检测算子：
$$ Sobel_{x} = \frac{1}{9}\left[ \begin{matrix} -1 &amp;amp; 0 &amp;amp; 1 \newline -2 &amp;amp; 0 &amp;amp; 2 \newline -1 &amp;amp; 0 &amp;amp; 1 \end{matrix} \right] $$</description>
    </item>
    
    <item>
      <title>OpenCV-python-4</title>
      <link>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/</link>
      <pubDate>Thu, 20 Feb 2020 14:14:07 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/</guid>
      <description>一、OpenCV与NumPy OpenCV 读取一张图片，返回的实际上是一个numpy.ndarray类。所以一些对numpy.ndarray的操作可以直接对cv2.imread()返回的对象使用。
import cv2 import numpy as np img = cv2.imread(&#39;connelly.jpg&#39;) print(type(img)) # &amp;lt;class &#39;numpy.ndarray&#39;&amp;gt; rows, cols = img.shape[:2] print(rows, cols) # 210 270  1.1 访问和修改像素值 根据像素值的行和列坐标可以访问特定像素点。对于 BGR 图像，它返回一个蓝色、绿色、红色值数组。灰度图像，只返回相应的亮度。
px = img[100, 120] img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) px_gray = img_gray[100, 120] print(px) # [130 131 181] print(px_gray) # 146  可以用同样的方式修改像素值。
img[100, 120] = [255,255,255]  NumPy 是一个用于快速数组计算的优化库。因此，使用原生 python 的数组简单地访问每个像素值，并修改它将非常缓慢，不推荐这种方法。
上述方法通常用于选择数组区域，例如前 5 行和最后 3 列。对于单个像素访问，但用 NumPy 数组的方法、array.tem()和array.itemset()会更适合。因为它总是返回一个标量。因此，如果想访问所有的 B，G，R 值，你需要为所有通道分别调用array.</description>
    </item>
    
    <item>
      <title>OpenCV-python-3</title>
      <link>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/</link>
      <pubDate>Wed, 19 Feb 2020 13:00:33 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/</guid>
      <description>一、图片混合 1.1 图像混合 图像混合cv2.addWeighted()要求两幅图片的形状（高度/宽度/通道数）必须相同，$ \omega_{1} $ 和 $ \omega_{2} $ 分别为两幅图像的权重，b 则是一个偏置：
$$ dst = \omega_{1}\times img1+\omega_{2}\times img2 + b $$
img1 = cv2.imread(&#39;img1_name.jpg&#39;) img2 = cv2.imread(&#39;img2_name.png&#39;) res = cv2.addWeighted(img1, 0.6, img2, 0.4, 0)  特别的，当 $ \omega_{1} $ 和 $ \omega_{2} $ 都为1，b 为 0 时，就是两张图片相加。可以用cv2.add()函数。numpy 中可以直接用res = img1 + img2相加，但这两者的结果并不相同：
x = np.uint8([250]) y = np.uint8([10]) print(cv2.add(x, y)) # 250 + 10 = 260 =&amp;gt; 255 --255封顶 print(x + y) # 250 + 10 = 260 % 256 = 4 --会溢出  1.</description>
    </item>
    
    <item>
      <title>OpenCV-python-2</title>
      <link>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</link>
      <pubDate>Mon, 17 Feb 2020 14:44:55 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</guid>
      <description>一、滤波 滤波是一种卷积操作，常用于图像的预处理。低通滤波器就是允许低频信号通过，在图像中边缘和噪点都相当于高频部分，所以低通滤波器用于去除噪点、平滑和模糊图像。高通滤波器则反之，用来增强图像边缘，进行锐化处理。
 低通滤波器是模糊 高通滤波器是锐化  常见噪声有椒盐噪声和高斯噪声，椒盐噪声可以理解为斑点，随机出现在图像中的黑点或白点；高斯噪声可以理解为拍摄图片时由于光照等原因造成的噪声。
1.1 均值滤波 均值滤波是一种最简单的滤波处理，它取的是卷积核区域内元素的均值，用cv2.blur()实现，如3×3的卷积核：
$$ kernel_{m} = \frac{1}{9}\left[ \begin{matrix} 1 &amp;amp; 1 &amp;amp; 1 \newline 1 &amp;amp; 1 &amp;amp; 1 \newline 1 &amp;amp; 1 &amp;amp; 1 \end{matrix} \right] $$
img = cv2.imread(&#39;lena.jpg&#39;) blur = cv2.blur(img, (3, 3)) # 均值模糊  1.2 方框滤波 方框滤波跟均值滤波很像，如3×3的滤波核如下：
$$ kernel_{b} = a\left[ \begin{matrix} 1 &amp;amp; 1 &amp;amp; 1 \newline 1 &amp;amp; 1 &amp;amp; 1 \newline 1 &amp;amp; 1 &amp;amp; 1 \end{matrix} \right] $$</description>
    </item>
    
    <item>
      <title>OpenCV-python-1</title>
      <link>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 09 Feb 2020 15:57:11 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>18年结束毕业设计之后，对OpenCV接触很少了。那时使用的是C++，借由最近使用python较多，学习OpenCV-python算是一种温故。本文主要参考了OpenCV-Python图像处理教程以及官方文档。
一、图片 需要注意图片的x，y轴排布，三通道以B-G-R排布，灰度图只有一个通道。
1.1 读取 # 加载灰度图 img = cv2.imread(&#39;lena.jpg&#39;, 0)   参数1：图片的文件名  如果图片放在当前文件夹下，直接写文件名就行了，如&amp;rsquo;lena.jpg&amp;rsquo; 否则需要给出绝对路径，如&amp;rsquo;D:\OpenCVSamples\lena.jpg&amp;rsquo;   参数2：读入方式，省略即采用默认值  cv2.IMREAD_COLOR：彩色图，默认值(1) cv2.IMREAD_GRAYSCALE：灰度图(0) cv2.IMREAD_UNCHANGED：包含透明通道的彩色图(-1)    1.2 显示 # 创建窗口 cv2.namedWindow(&#39;lena2&#39;, cv2.WINDOW_NORMAL)   参数1：窗口名称 参数2：窗口模式  cv2.WINDOW_AUTOSIZE表示窗口大小自适应图片 cv2.WINDOW_NORMAL表示窗口大小可调整    # 显示图片 cv2.imshow(&#39;lena&#39;, img)   参数1：窗口名称 参数2：图片实例  # 保持图片显示 cv2.waitKey(0)    参数：暂停时长，ms
为0时，表示无限长。
  传回按键的ascii码, 如ESC:27、s:115
  1.3 保存 # 保存图片 cv2.</description>
    </item>
    
    <item>
      <title>2019-nCoV疫情数据可视化地图</title>
      <link>https://lil-q.github.io/blog/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9C%B0%E5%9B%BE/</link>
      <pubDate>Sat, 01 Feb 2020 22:41:13 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9C%B0%E5%9B%BE/</guid>
      <description>数据的获取 在学习该博客的数据爬取时发现数据似乎已经不再更新，所以重新在腾讯新闻网站搜索相关数据。
使用time、json和requests获取数据。
import time, json, requests url = &#39;https://view.inews.qq.com/g2/getOnsInfo?name=disease_h5&amp;amp;callback=&amp;amp;_=%d&#39;%int(time.time()*1000) data = json.loads(requests.get(url=url).json()[&#39;data&#39;]) print(data)  可以看到数据如下所示（省略部分内容）：
{&#39;chinaTotal&#39;: {&#39;date&#39;: &#39;02.01&#39;, &#39;confirm&#39;: &#39;11890&#39;, &#39;suspect&#39;: &#39;17988&#39;, &#39;dead&#39;: &#39;259&#39;, &#39;heal&#39;: &#39;269&#39;}, &#39;lastUpdateTime&#39;: &#39;2020-02-01 21:18:01&#39;, &#39;areaTree&#39;: [{&#39;name&#39;: &#39;中国&#39;, &#39;children&#39;: [{&#39;name&#39;: &#39;湖北&#39;, &#39;children&#39;: [...], &#39;total&#39;: {&#39;confirm&#39;: 7153, &#39;suspect&#39;: 0, &#39;dead&#39;: 249, &#39;heal&#39;: 166}, &#39;today&#39;: {&#39;confirm&#39;: 1347, &#39;suspect&#39;: -49, &#39;dead&#39;: 49, &#39;heal&#39;: 15}}, {&#39;name&#39;: &#39;浙江&#39;, &#39;children&#39;: [...], &#39;total&#39;: {&#39;confirm&#39;: 599, &#39;suspect&#39;: 0, &#39;dead&#39;: 0, &#39;heal&#39;: 20}, &#39;today&#39;: {&#39;confirm&#39;: 62, &#39;suspect&#39;: 0, &#39;dead&#39;: 0, &#39;heal&#39;: 7}}, .</description>
    </item>
    
    <item>
      <title>SQL</title>
      <link>https://lil-q.github.io/blog/sql/</link>
      <pubDate>Thu, 16 Jan 2020 13:59:07 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/sql/</guid>
      <description>SQL基础语句快查
原教程地址：http://www.xuesql.cn/
一、定义 1.1 什么是SQL SQL, 全称为Structured Query Language（结构化查询语言)。 要讲SQL就绕不开database(数据库), 平时所说的数据库，一般就是指的 Relational database(关系型数据库)。
大家知道数据库是用来存储大量数据的一种软件，那么SQL呢是用来操作数据里的数据，具体来说SQL可以做数据查询，数据更新，写入数据等等。
1.2 关系型数据库 在学习SQL语法之前有必要解释一下什么是关系型数据库（Relational databases)？数据库由若干张表(Table)组成，这里说的数据Table很像Excel里的表; 正如Excel里的表格，Table也是由 行(rows)和列(columns)组成。
一个Table存储一个类别的数据，每一行是一条数据，每一列是这种数据的一个属性； Table就像一个二维的表格，列(columns)是有限固定的，行(rows)是无限不固定的。
二、查询(SELECT) Select 查询某些属性列（specific columns）的语法。
SELECT column（列名）, another_column, … FROM mytable（表名）;  Select 查询所有列。
SELECT * FROM mytable（表名）;  三、条件查询 (WHERE) 条件查询语法。WHERE
SELECT column, another_column, … FROM mytable WHERE condition AND/OR another_condition AND/OR …;  参考下表：
   Operator（关键字） Condition（意思） SQL Example(例子）     =, !=, &amp;lt; &amp;lt;=, &amp;gt;, &amp;gt;= Standard numerical operators 基础的 大于，等于等比较 col_name !</description>
    </item>
    
    <item>
      <title>图论</title>
      <link>https://lil-q.github.io/blog/%E5%9B%BE-graph/</link>
      <pubDate>Fri, 27 Dec 2019 17:53:49 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E5%9B%BE-graph/</guid>
      <description>生活不就是一张图吗？
一、定义 图(Graph)用于表示物件与物件之间的关系，是图论的基本研究对象。一张图由一些小圆点（称为顶点或结点）和连结这些圆点的直线或曲线（称为边）组成。
一个图 $G$ 是一个二元组，即序偶 $\langle V,E\rangle$ ，或记作 $G= \langle V,E\rangle$ ，其中 $V$ 是有限非空集合，称为 $G$ 的顶点集， $V$ 中的元素称为顶点或结点； $E$ 称为 $G$ 的边的集合， $\forall e_i \in E$ ，都有 $V$ 中的结点与之对应，称 $e_i$ 为 $G$ 的边。
简单来说，就是图 $G$ 就是一个结点的集合 $V$ 和边的集合 $E$ ，其中任意一条边都可以表示为两个结点之间的关系。若 $e_i\in E$ 表示为 $\langle u,v\rangle$ ，则有 $u\in V , v\in V$ 。
1.1 基本概念 无向图：每条边都是无向边的图。
有向图：每条边都是有向边的图。
有权图：每条边具有一定的权重(weight)，通常是一个数字
无权图：每条边均没有权重，也可以理解为权为 1
连通图：所有的点都有路径相连
非连通图：存在某两个点没有路径相连
邻接：关联于同一条边的两个点 $u$ 和 $v$ 称为邻接的；关联于同一个点的两条边 $e_1$ 和 $e_2$ 是邻接的（或相邻的）。</description>
    </item>
    
    <item>
      <title>排序算法</title>
      <link>https://lil-q.github.io/blog/%E6%8E%92%E5%BA%8F-sort-%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 16 Nov 2019 19:34:55 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E6%8E%92%E5%BA%8F-sort-%E7%AE%97%E6%B3%95/</guid>
      <description>十种排序算法的python实现及复杂度分析
分类 评价排序算法的几个指标：
 时间复杂度：包括平均时间复杂度、最坏时间复杂度和最好时间复杂度。一般而言，好的性能是$O(nlog_2n)$，坏的性能是$O(n^2)$。对于一个排序理想的性能是O(n)，但平均而言不可能达到。基于比较的排序算法对大多数输入而言至少需要$O(nlog_2n)$。 空间复杂度：内存使用量 稳定性： 稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。 依据排序的方法：插入、交换、选择、合并等等。  本文介绍了以下几种排序，推荐可视化网站visualgo，下文代码都采用数组作为输入。
   排序方法 平均时间复杂度 最坏时间复杂度 最好时间复杂度 空间复杂度 稳定性     冒泡排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 稳定   选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定   插入排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 稳定   堆排序 $O(nlog_2n)$ $O(nlog_2n)$ $O(nlog_2n)$ $O(1)$ 不稳定   归并排序 $O(nlog_2n)$ $O(nlog_2n)$ $O(nlog_2n)$ $O(n)$ 稳定   快速排序 $O(nlog_2n)$ $O(n^2)$ $O(nlog_2n)$ $O(log_2n)$ 不稳定   希尔排序 $O(n^{1.</description>
    </item>
    
  </channel>
</rss>