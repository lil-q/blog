<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on Homeward</title>
    <link>https://lil-q.github.io/blog/</link>
    <description>Recent content in Blogs on Homeward</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>{year} © lil-q</copyright>
    <lastBuildDate>Thu, 23 Jul 2020 09:46:01 +0000</lastBuildDate>
    
	<atom:link href="https://lil-q.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>HTTP &amp; RESTful</title>
      <link>https://lil-q.github.io/blog/http-restful/</link>
      <pubDate>Thu, 23 Jul 2020 09:46:01 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/http-restful/</guid>
      <description>HyperText Transfer Protocol &amp;amp; REpresentational State Transfer
一、概述 超文本传输协议（HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。
表现层状态转换（REST）本身并没有创造新的技术、组件或服务，而隐藏在 RESTful 背后的理念就是使用 Web 的现有特征和能力， 更好地使用现有 Web 标准中的一些准则和约束。虽然 REST 本身受 Web 技术的影响很深， 但是理论上 REST 架构风格并不是绑定在 HTTP 上，只不过目前 HTTP 是唯一与 REST 相关的实例。
1.1 URI 统一资源标识符（Uniform Resource Identifier，URI）是一个用于标识某一互联网资源名称的字符串。URI的最常见的形式是统一资源定位符（Uniform Resource Locator，URL），经常指定为非正式的网址。更罕见的用法是统一资源名称（Uniform Resource Name，URN），其目的是通过提供一种途径。用于在特定的名字空间资源的标识，以补充网址。在RESTful架构中 URI 不应该有动词，动词应该放在HTTP协议中。
资源是一种信息实体，它可以有多种外在表现形式。“资源”具体呈现出来的形式，叫做它的&amp;quot;表现层&amp;rdquo;（Representation）。URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的 &amp;ldquo;.html&amp;rdquo; 后缀名是不必要的，因为这个后缀名表示格式，属于&amp;quot;表现层&amp;quot;范畴，而 URI 应该只代表&amp;quot;资源&amp;quot;的位置。它的具体表现形式，应该在 HTTP 请求的头信息中用 Accept 和 Content-Type 字段指定，这两个字段才是对&amp;quot;表现层&amp;quot;的描述。
因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个 URI。版本号可以在 HTTP 请求头信息的 Accept 字段中进行区分（参见Versioning REST Services）：
1.2 如何理解 RESTful REST 本身受 Web 技术的影响很深，可以借助 WEB 来理解 RESTful。网站是采用客户端/服务器模式，建立在分布式体系上，通过互联网通信，具有高延时（high latency）、高并发等特点的一种软件。表现层（Representation）的含义是把资源具体的形式呈现出来。表现层上的网站交互就是客户端获取或修改服务器端储存的资源，而这些获取或修改的操作就是资源的状态转换。具体的实现很简单</description>
    </item>
    
    <item>
      <title>MySQL</title>
      <link>https://lil-q.github.io/blog/mysql/</link>
      <pubDate>Fri, 17 Jul 2020 16:16:51 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/mysql/</guid>
      <description>/maɪ ˌɛskjuːˈɛl/
一、索引 优势：减少 I/O 次数，加快检索速度；根据索引分组和排序，可以加快分组和排序；
劣势：索引本身也是表，因此会占用存储空间，一般来说，索引表占用的空间的数据表的1.5倍；索引表的维护和创建需要时间成本，这个成本随着数据量增大而增大；构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表。
常见的索引类型有：主键索引、唯一索引、普通索引、全文索引、组合索引
（1）主键索引：即主索引，根据主键pk_clolum（length）建立索引，不允许重复，不允许空值
ALTER TABLE &#39;table_name&#39; ADD PRIMARY KEY pk_index(&#39;col&#39;)；  （2）唯一索引：用来建立索引的列的值必须是唯一的，允许空值
ALTER TABLE &#39;table_name&#39; ADD UNIQUE index_name(&#39;col&#39;)；  （3）普通索引：用表中的普通列构建的索引，没有任何限制
ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col&#39;)；  （4）全文索引：用大文本对象的列构建的索引
ALTER TABLE &#39;table_name&#39; ADD FULLTEXT INDEX ft_index(&#39;col&#39;)；  （5）组合索引：用多个列组合构建的索引，这多个列中的值不允许有空值
ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col1&#39;,&#39;col2&#39;,&#39;col3&#39;)；  1.1 实现原理 1. B+ 数 B 树（B-tree）是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B 树，概括来说是一个一般化的二叉查找树（binary search tree）一个节点可以拥有2个以上的子节点。与自平衡二叉查找树不同，B 树适用于读写相对大的数据块的存储系统，例如磁盘。B 树减少定位记录时所经历的中间过程，从而加快存取速度。B 树这种数据结构可以用来描述外部存储。这种数据结构常被应用在数据库和文件系统的实现上。
B+ 树是一种树数据结构，通常用于数据库和操作系统的文件系统中。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入，这与二叉树恰好相反。
请参考这篇文章
B+ 树与B 树最大的不同是内部结点不保存数据，只用于索引，所有数据（或者说记录）都保存在叶子结点中。</description>
    </item>
    
    <item>
      <title>数据库原理</title>
      <link>https://lil-q.github.io/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Thu, 16 Jul 2020 20:30:14 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>就像操作系统屏蔽了硬件访问复杂性那样，数据库屏蔽了数据访问的复杂性。
一、事务 事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。
1.1 ACID 1. 原子性 事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。
回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。
2. 一致性 数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。
3. 隔离性 一个事务所做的修改在最终提交以前，对其它事务是不可见的。
4. 持久性 一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。
系统发生奔溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。
1.2 关系   一致性，保证事务的执行结果正确：
 无并发：事务串行执行，隔离性一定能够满足；只需满足原子性。 有并发：多个事务并行执行，事务不仅要满足隔离性；还需要满足原子性。    持久性，应对系统崩溃。
  二、并发一致性问题 在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。
1. 丢失修改 丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。
例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。
2. 读脏数据 读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。
例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。
3. 不可重复读 不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。
例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</description>
    </item>
    
    <item>
      <title>java-虚拟机</title>
      <link>https://lil-q.github.io/blog/java-%E8%99%9A%E6%8B%9F%E6%9C%BA/</link>
      <pubDate>Tue, 07 Jul 2020 11:17:47 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java-%E8%99%9A%E6%8B%9F%E6%9C%BA/</guid>
      <description>一、内存区域 1.1 程序计数器 程序计数器是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都依赖这个计数器。记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。
1.2 Java 虚拟机栈 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
该区域可能抛出以下异常：
 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常； 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。  1.3 本地方法栈 本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。
本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。
1.4 堆 所有对象都在这里分配内存，是垃圾收集的主要区域（&amp;ldquo;GC 堆&amp;rdquo;）。
现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：
 新生代（Young Generation） 老年代（Old Generation）  堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。
栈和堆的区别如下：
 功能：栈的功能是运行，堆的功能是储存； 共享性：栈是线程隔离的，堆是线程共享的； 异常错误 ：栈可能出 StackOverflowError 异常和 OutOfMemoryError 异常，堆出后者； 空间：栈的空间连续，堆的空间不连续，栈的空间远小于堆。  1.5 方法区 用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。
对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。
HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</description>
    </item>
    
    <item>
      <title>设计模式-创建型</title>
      <link>https://lil-q.github.io/blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%9E%8B/</link>
      <pubDate>Tue, 12 May 2020 23:30:13 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%9E%8B/</guid>
      <description>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。
一、单例(Singleton) 单例模式属于创建型设计模式，确保一个类只有一个实例，并提供该实例的全局访问点。
实现: 使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。
1.1 懒汉式——线程不安全 所谓懒汉就是私有静态变量 uniqueInstance 被延迟实例化（lazy loading），这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。
这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 if (uniqueInstance == null) ，并且此时 uniqueInstance == null，那么会有多个线程执行 uniqueInstance = new Singleton(); 语句，这将导致实例化多次 uniqueInstance。
public class Singleton { private static Singleton uniqueInstance; private Singleton(){} public static Singleton newInstance(){ if(uniqueInstance == null) uniqueInstance = new Singleton(); return uniqueInstance; } }  1.2 懒汉式——线程安全 为了解决线程安全的问题，我们可以直接在newInstance()方法上面直接加上一把synchronized同步锁。那么在一个时间点只能有一个线程能够进入该方法，从而避免了实例化多次 uniqueInstance。
但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 uniqueInstance 已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。
public static synchronized Singleton newInstance(){ if(uniqueInstance == null) uniqueInstance = new Singleton(); return uniqueInstance; }  1.</description>
    </item>
    
    <item>
      <title>操作系统</title>
      <link>https://lil-q.github.io/blog/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Sun, 10 May 2020 00:08:33 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
      <description>&lt;p&gt;操作系统是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>计算机网络</title>
      <link>https://lil-q.github.io/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Tue, 05 May 2020 19:30:17 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</guid>
      <description>网络把主机连接起来，而互连网（internet）是把多种不同的网络连接起来，因此互连网是网络的网络。
一、概述 1. 主机之间的通信方式   客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。
  对等（P2P）：不区分客户和服务器。
  2. 报文交换  电路交换：整个报文的比特流连续地从源点直达终点，好像在一个管道中传送一样。 报文交换：整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。 分组交换：单个分组（如p1，整个报文的一部分）传送到相邻结点，存储下来后查找转发表，转达到下一个结点。  3. 时延 总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延
（1）排队时延
分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。
（2）处理时延
主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。
（3）传输时延
主机或路由器传输数据帧所需要的时间。
（4）传播时延
电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。
4. 体系结构   应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。
  传输层 ：为进程提供通用的数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。
以上为端到端，以下为点到点：
  网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。
  数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。
  物理层 ：考虑如何在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。
  （1）协议</description>
    </item>
    
    <item>
      <title>Morris 算法</title>
      <link>https://lil-q.github.io/blog/morris%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 01 May 2020 14:51:08 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/morris%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;p&gt;morris 遍历利用的是树的叶节点左右孩子为空（树的大量空闲指针），实现空间开销的极限缩减。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>java-并发</title>
      <link>https://lil-q.github.io/blog/java-%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Tue, 28 Apr 2020 19:37:01 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java-%E5%B9%B6%E5%8F%91/</guid>
      <description>计算机的运算速度与它的存储和通信子系统的速度差距太大，大量的时间都花费在磁盘 I/O、网络通信或者数据库访问上。高效并发能能更好的利用计算机的性能。另一方面，一个服务器要同时对多个客户端提供服务。衡量一个服务性能的高低好坏，每秒事务处理数（Transaction Per Second，TPS）是重要的指标之一，其与程序的并发能力有着密切关系。题解
一、硬件的效率和一致性 由于计算机的存储设备与处理器的运算速度有着几个数量级的差距，所以现代计算机系统都不得不加入一层或多层读写速度尽可能接近处理器运算速度的**高速缓存（ Cache）**来作为内存与处理器之间的缓冲：将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。
基于高速缓存的存储交互很好地解决了处理器与内存速度之间的矛盾，但是也为计算机系统带来更高的复杂度，它引入了一个新的问题：缓存一致性（ Cache Coherence）。在多路处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（ Main Memory），这种系统称为共享内存多核系统（ Shared Memory Multiprocessors System），如下图所示。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。
为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作。
除了増加高速缓存之外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java 虚拟机的即时编译器中也有指令重排序（ Instruction Reorder）优化。
二、Java 内存模型 Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。
 此处的变量（Variables）与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。
 Java内存模型规定了所有的变量都存储在主内存（ Main Memory，与硬件的主内存同名，但物理上它仅是虚拟机内存的一部分）。每条线程还有自己的工作内存（ Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成（如果局部变量是一个 reference 类型，它引用的对象在Java堆中可被各个线程共享，但是 reference 本身在 Java 栈的局部变量表中是线程私有的）。
2.1 内存间交互操作 Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于 double 和 long 类型的变量来说， load、 store、read 和 write 操作在某些平台r上允许有例外）。
 lock：作用于主内存的变量，标识为一条线程独占。 unlock：作用于主内存的变量，释放处于锁定状态的变量。 read：作用于主内存的变量，传输到工作内存中。 load：作用于工作内存的变量，在 read 之后执行，把值放入工作内存的变量副本中。 use：作用于工作内存的变量，传递给执行引擎。 assign：作用于工作内存的变量，把一个从执行引擎接收到的值赋给工作内存的变量。 store：作用于工作内存的变量，把一个变量的值传送到主内存中。 write：作用于主内存的变量，在 store 之后执行，把值放入主内存的变量中。  2.</description>
    </item>
    
    <item>
      <title>贪心算法</title>
      <link>https://lil-q.github.io/blog/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 22 Apr 2020 20:42:19 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</guid>
      <description>一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。
一、概述 贪心算法（greedy algorithm），又称贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。比如在旅行推销员问题中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。
贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。
贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。
贪心法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码……对于其他问题，贪心法一般不能得到我们所要求的答案。一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。
二、流程  创建数学模型来描述问题。 把求解的问题分成若干个子问题。 对每一子问题求解，得到子问题的局部最优解。 把子问题的解局部最优解合成原来解问题的一个解。  三、题解 回溯算法，动态规划和贪心算法其实是循序渐进的。回溯算法即是暴力的枚举，每一步对所有可能都进行计算，计算到达终点即返回，每一步返回后都要把状态回归到之前的状态。回溯算法的痛点是他有很多重复的计算，解决的办法是引入备忘录，备忘录记录了每一步的结果，这其实就是子问题的最优解，动态规划由此产生。所以使用动态规划时必须要满足无后效性，子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。如果一个问题没有重叠子问题，那就只能使用回溯算法，比如N皇后问题。
对于有些问题，我们通过建立数学模型之后明确知道了子问题的最优解，那么就不需要枚举各种情况了。比如有 5 元，2 元和 1 元三种硬币无限个，求用这些硬币兑换 x 元的最少硬币个数。解决这个问题总是先考虑最大面额的硬币，并不需要枚举。但是对于 5 元，4 元和 1 元这三个面额，贪心算法并不能得出最优解。
加油站 leetcode 134. 加油站：在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。
说明:
 如果题目有解，该答案即为唯一答案。 输入数组均为非空数组，且长度相同。 输入数组中的元素均为非负数。  示例:
输入: gas = [1,2,3,4,5] cost = [3,4,5,1,2] 输出: 3  这个问题的子问题是从第 i 个加油站出发，到达每个站的油量大于等于 0 ，则返回这个节点。
遍历所有节点，cur记录当前节点油箱内剩余油量，p记录可能的起点。如果cur小于 0 ，那么这个节点包括之前的节点都不可能是起点，将cur置 0 ，p置为下一个节点。</description>
    </item>
    
    <item>
      <title>java-I/O</title>
      <link>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E5%85%AD/</link>
      <pubDate>Sat, 04 Apr 2020 14:13:57 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E5%85%AD/</guid>
      <description>一、IO 1.1 File  创建File f = new File(&amp;quot;C:\\Windiws\\...&amp;quot;)对象本身不涉及IO操作，并不会导致任何磁盘操作； 可以获取路径／绝对路径／规范路径：getPath()/getAbsolutePath()/getCanonicalPath()； 可以获取目录的文件和子目录：list()/listFiles()； boolean mkdir()：创建当前File对象表示的目录； boolean mkdirs()：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来； boolean delete()：删除当前File对象表示的目录，当前目录必须为空才能删除成功。  Java I/O 使用了装饰者模式来实现。以 InputStream 为例，
 InputStream 是抽象组件； FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作； FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。  实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。
1.2 输入 InputStream就是Java标准库提供的最基本的输入流。它位于java.io这个包里。java.io包提供了所有同步IO的功能。
InputStream并不是一个接口，而是一个抽象类，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是int read()：
public abstract int read() throws IOException;  这个方法会读取输入流的下一个字节，并返回字节表示的int值（0~255）。如果已读到末尾，返回-1表示不能继续读取了。
FileInputStream是InputStream的一个子类，能从文件流中读取数据。使用try(resource)可以保证InputStream正确关闭（因为InputStream和OutputStream都实现了java.lang.AutoCloseable接口）。
public void readFile() throws IOException { try (InputStream input = new FileInputStream(&amp;quot;src/readme.txt&amp;quot;)) { int n; while ((n = input.</description>
    </item>
    
    <item>
      <title>java-Map</title>
      <link>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E4%BA%94/</link>
      <pubDate>Thu, 02 Apr 2020 15:37:30 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E4%BA%94/</guid>
      <description>一、Map Map是一种键-值映射表，当我们调用put(K key, V value)方法时，就把key和value做了映射并放入Map。当我们调用V get(K key)时，就可以通过key获取到对应的value。如果key不存在，则返回null。和List类似，Map也是一个接口，最常用的实现类是HashMap。
 TreeMap：基于红黑树实现。 HashMap：基于哈希表实现。 HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。  1.1 Map遍历 要遍历key可以使用for each循环遍历Map实例的keySet()方法返回的Set集合，它包含不重复的key的集合：
for (String key : map.keySet()) {...}  同时遍历key和value可以使用for each循环遍历Map对象的entrySet()集合，它包含每一个key-value映射：
for (Map.Entry&amp;lt;String, Integer&amp;gt; entry : map.entrySet()) {...}  1.2 equals() &amp;amp; hashCode() 正确使用Map必须保证：
 作为key的对象必须正确覆写equals()方法，相等的两个key实例调用equals()必须返回true； 作为key的对象还必须正确覆写hashCode()方法，且hashCode()方法要严格遵循以下规范：  如果两个对象相等，则两个对象的hashCode()必须相等； 如果两个对象不相等，则两个对象的hashCode()尽量不要相等。    自己写hashCode()时R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：31*x == (x&amp;lt;&amp;lt;5)-x，编译器会自动进行这个优化。
@Override public int hashCode() { int result = 17; result = 31 * result + x; result = 31 * result + y; result = 31 * result + z; return result; }  和实现equals()方法遇到的问题类似，如果firstName或lastName为null，上述代码工作起来就会抛NullPointerException。为了解决这个问题，我们在计算hashCode()的时候，经常借助Objects.</description>
    </item>
    
    <item>
      <title>java-Collection</title>
      <link>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E5%9B%9B/</link>
      <pubDate>Mon, 30 Mar 2020 18:34:55 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E5%9B%9B/</guid>
      <description>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。
 源码基于java 13。
 一、Collection 二、List List接口，可以看到几个主要的接口方法：
 在末尾添加一个元素：void add(E e) 在指定索引添加一个元素：void add(int index, E e) 删除指定索引的元素：int remove(int index) 删除某个元素：int remove(Object e) 获取指定索引的元素：E get(int index) 获取链表大小（包含元素的个数）：int size()  List接口允许我们添加重复的元素，即List内部的元素可以重复，List还允许添加null。调用List.of()，它返回的是一个只读List：
List&amp;lt;Integer&amp;gt; list = List.of(1, 2, 5);  但是List.of()方法不接受null值，如果传入null，会抛出NullPointerException异常。
2.1 List遍历 List的遍历采用了迭代器的设计模式：
Iterable接口声明如下：
public interface Iterable&amp;lt;T&amp;gt; { Iterator&amp;lt;T&amp;gt; iterator(); }  Iterator接口声明如下：
public interface Iterator&amp;lt;E&amp;gt; { // 判断是否还有下一个对象，如果有，则返回true，否则false boolean hasNext(); // 返回集合的下个值，此方法只能在hasNext方法返回true时调用 E next(); // 删除集合的当前值，此方法也只能在hasNext方法返回true时调用 void remove(); }  ListIterator接口声明如下：</description>
    </item>
    
    <item>
      <title>java-反射和泛型</title>
      <link>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E4%B8%89/</link>
      <pubDate>Fri, 27 Mar 2020 22:45:02 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E4%B8%89/</guid>
      <description>一、反射 由于 JVM 为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息。这种通过Class实例获取class信息的方法称为反射（Reflection）。
Java 反射主要提供以下功能：
 在运行时判断任意一个对象所属的类； 在运行时构造任意一个类的对象； 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）； 在运行时调用任意一个对象的方法。  重点：是运行时而不是编译时。
1.1 Class类 获取一个class的Class实例有三个方法：
方法一：直接通过一个class的静态变量class获取：
Class&amp;lt;?&amp;gt; cls = String.class;  方法二：如果我们有一个实例变量，可以通过该实例变量提供的getClass()方法获取：
String s = &amp;quot;Hello&amp;quot;; Class&amp;lt;?&amp;gt; cls = s.getClass();  方法三：如果知道一个class的完整类名，可以通过静态方法Class.forName()获取：
Class&amp;lt;?&amp;gt; cls = Class.forName(&amp;quot;java.lang.String&amp;quot;);  Class.forName()加载类时默认会初始化，而ClassLoader.loadClass()默认不会初始化，只完成了类加载中的第一步加载。
注意Class实例==比较和instanceof的差别：
Integer n = new Integer(123); boolean b1 = n instanceof Integer; // true，因为n是Integer类型 boolean b2 = n instanceof Number; // true，因为n是Number类型的子类 boolean b3 = n.getClass() == Integer.class; // true，因为n.getClass()返回Integer.class boolean b4 = n.</description>
    </item>
    
    <item>
      <title>java-面向对象和异常处理</title>
      <link>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E4%BA%8C/</link>
      <pubDate>Mon, 23 Mar 2020 14:08:20 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E4%BA%8C/</guid>
      <description>一、面向对象 Java是一种面向对象的编程语言。面向对象编程，英文是Object-Oriented Programming，简称OOP。
1.1 权限修饰符     本类 同一个包下（子类和无关类） 不同包下（子类） 不同包下（无关类）     private Y      default Y Y     protected Y Y Y    public Y Y Y Y    一个.java文件只能包含一个public类，但可以包含多个非public类。如果有public类，文件名必须和public类的名字相同。
1.2 继承 如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法。
子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。
 **向上转型（upcasting）：**一个子类类型安全地变为父类类型的赋值。向上转型只能够调用子类重写的方法。 **向下转型（downcasting）：**一个父类类型强制转型为子类类型。找回向上转型时丢失的子类扩展方法。  instanceof判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为null，那么对任何instanceof的判断都为false。
利用instanceof，在向下转型前可以先判断：
Person p = new Student(); if (p instanceof Student) { // 只有判断成功才会向下转型: Student s = (Student) p; // 一定会成功 }  从Java 14开始，判断instanceof后，可以直接转型为指定变量，避免再次强制转型。</description>
    </item>
    
    <item>
      <title>java-基础</title>
      <link>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Fri, 20 Mar 2020 19:33:14 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80/</guid>
      <description>JVM–java virtual machine JVM 是整个 java 实现跨平台的最核心的部分，所有的 java 程序会首先被编译为 .class 的类文件，这种类文件可以在虚拟机上执行，也就是说 class 并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。 JRE – java runtime environment JRE 是指 java 运行环境。在 JDK 的安装目录里你可以找到 jre 目录，里面有两个文件夹 bin 和 lib ，在这里可以认为 bin 里的就是 jvm，lib 中则是 jvm 工作所需要的类库，而 bin 和 lib 和起来就称为 JRE。 JDK – java development kit JDK 是 java 开发工具包，是支持 java 程序开发的最小环境。JDK 对比 JRE 多了 java language 和工具 API。  一、数据类型 1.1 基本类型  byte/8 [-128 ~ 127] char/16 short/16 [-32768 ~ 32767] int/32 [-2147483648 ~ 2147483647] float/32 long/64 [-9223372036854775808 ~ 9223372036854775807] double/64 boolean/~  Java语言对布尔类型的存储并没有做规定，因为理论上存储布尔类型只需要1 bit，但是通常JVM内部会把boolean表示为4字节整数，为了节省内存而表示为更小的类型可能会在之后处理时带来不必要的麻烦。</description>
    </item>
    
    <item>
      <title>回溯算法</title>
      <link>https://lil-q.github.io/blog/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 08 Mar 2020 13:12:02 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</guid>
      <description>“想回到过去，试着让故事继续”
回溯 回溯（backtracking）是暴力搜索法中的一种。
对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题。
 约束满足问题：在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解。
 回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步执行的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将撤销上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案，找到答案即算法运行至终止条件。
回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：
 找到一个可能存在的正确的答案 在尝试了所有可能的分步方法后宣告该问题没有答案  在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。
典型的回溯 leetcode 46. 全排列：给定一个没有重复数字的序列，返回其所有可能的全排列。
示例:
输入: [1,2,3] 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]  用比较通用的回溯算法可以这样解答：
class Solution: def permute(self, nums: List[int]) -&amp;gt; List[List[int]]: size = len(nums) res = [] # 记录已经选择过的数 visited = set() def backtrack(numList, visited): # 当所有数字都选完了，终止 if len(visited) == size: res.append(numList[:]) # 注意深拷贝和浅拷贝的问题 return # 遍历所有可能的选择 for i in range(size): # 如果这个数已在前面出现过了，跳过 if i in visited: continue visited.</description>
    </item>
    
    <item>
      <title>OpenCV-python-5</title>
      <link>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/</link>
      <pubDate>Sat, 22 Feb 2020 17:51:07 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/</guid>
      <description>一、图像梯度 在谈及梯度之前需要先找到函数，图片是二维的离散函数，二维意味着需要找到求梯度的方向，离散意味着对于图片的梯度不是导数而是差分。下式就是按照水平从左到右方向每隔一个像素点求差分：
$$ \Delta f\left ( i,j \right )=f\left ( i+1,j \right )-f\left ( i,j \right ) $$
1.1 Prewitt operator 将上式用卷积的方式处理是就可以是有下面这个卷积核（Prewitt 边缘检测算子）：
$$ Prewitt = \frac{1}{9}\left[ \begin{matrix} -1 &amp;amp; 0 &amp;amp; 1 \newline -1 &amp;amp; 0 &amp;amp; 1 \newline -1 &amp;amp; 0 &amp;amp; 1 \end{matrix} \right] $$
使用 Prewitt 算子处理后，值比较高的像素点意味着梯度较大，就是更解决边缘；值比较低的像素点意味着梯度较小，就是更解决平滑表面。
1.2 Sobel operator 考虑到对正在处理行的数据需要更多的重视，对 Prewitt 边缘检测算子改进就形成了 Sobel 边缘检测算子：
$$ Sobel_{x} = \frac{1}{9}\left[ \begin{matrix} -1 &amp;amp; 0 &amp;amp; 1 \newline -2 &amp;amp; 0 &amp;amp; 2 \newline -1 &amp;amp; 0 &amp;amp; 1 \end{matrix} \right] $$</description>
    </item>
    
    <item>
      <title>OpenCV-python-4</title>
      <link>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/</link>
      <pubDate>Thu, 20 Feb 2020 14:14:07 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/</guid>
      <description>一、OpenCV与NumPy OpenCV 读取一张图片，返回的实际上是一个numpy.ndarray类。所以一些对numpy.ndarray的操作可以直接对cv2.imread()返回的对象使用。
import cv2 import numpy as np img = cv2.imread(&#39;connelly.jpg&#39;) print(type(img)) # &amp;lt;class &#39;numpy.ndarray&#39;&amp;gt; rows, cols = img.shape[:2] print(rows, cols) # 210 270  1.1 访问和修改像素值 根据像素值的行和列坐标可以访问特定像素点。对于 BGR 图像，它返回一个蓝色、绿色、红色值数组。灰度图像，只返回相应的亮度。
px = img[100, 120] img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) px_gray = img_gray[100, 120] print(px) # [130 131 181] print(px_gray) # 146  可以用同样的方式修改像素值。
img[100, 120] = [255,255,255]  NumPy 是一个用于快速数组计算的优化库。因此，使用原生 python 的数组简单地访问每个像素值，并修改它将非常缓慢，不推荐这种方法。
上述方法通常用于选择数组区域，例如前 5 行和最后 3 列。对于单个像素访问，但用 NumPy 数组的方法、array.tem()和array.itemset()会更适合。因为它总是返回一个标量。因此，如果想访问所有的 B，G，R 值，你需要为所有通道分别调用array.</description>
    </item>
    
    <item>
      <title>OpenCV-python-3</title>
      <link>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/</link>
      <pubDate>Wed, 19 Feb 2020 13:00:33 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/</guid>
      <description>一、图片混合 1.1 图像混合 图像混合cv2.addWeighted()要求两幅图片的形状（高度/宽度/通道数）必须相同，$ \omega_{1} $ 和 $ \omega_{2} $ 分别为两幅图像的权重，b 则是一个偏置：
$$ dst = \omega_{1}\times img1+\omega_{2}\times img2 + b $$
img1 = cv2.imread(&#39;img1_name.jpg&#39;) img2 = cv2.imread(&#39;img2_name.png&#39;) res = cv2.addWeighted(img1, 0.6, img2, 0.4, 0)  特别的，当 $ \omega_{1} $ 和 $ \omega_{2} $ 都为1，b 为 0 时，就是两张图片相加。可以用cv2.add()函数。numpy 中可以直接用res = img1 + img2相加，但这两者的结果并不相同：
x = np.uint8([250]) y = np.uint8([10]) print(cv2.add(x, y)) # 250 + 10 = 260 =&amp;gt; 255 --255封顶 print(x + y) # 250 + 10 = 260 % 256 = 4 --会溢出  1.</description>
    </item>
    
    <item>
      <title>OpenCV-python-2</title>
      <link>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</link>
      <pubDate>Mon, 17 Feb 2020 14:44:55 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</guid>
      <description>一、滤波 滤波是一种卷积操作，常用于图像的预处理。低通滤波器就是允许低频信号通过，在图像中边缘和噪点都相当于高频部分，所以低通滤波器用于去除噪点、平滑和模糊图像。高通滤波器则反之，用来增强图像边缘，进行锐化处理。
 低通滤波器是模糊 高通滤波器是锐化  常见噪声有椒盐噪声和高斯噪声，椒盐噪声可以理解为斑点，随机出现在图像中的黑点或白点；高斯噪声可以理解为拍摄图片时由于光照等原因造成的噪声。
1.1 均值滤波 均值滤波是一种最简单的滤波处理，它取的是卷积核区域内元素的均值，用cv2.blur()实现，如3×3的卷积核：
$$ kernel_{m} = \frac{1}{9}\left[ \begin{matrix} 1 &amp;amp; 1 &amp;amp; 1 \newline 1 &amp;amp; 1 &amp;amp; 1 \newline 1 &amp;amp; 1 &amp;amp; 1 \end{matrix} \right] $$
img = cv2.imread(&#39;lena.jpg&#39;) blur = cv2.blur(img, (3, 3)) # 均值模糊  1.2 方框滤波 方框滤波跟均值滤波很像，如3×3的滤波核如下：
$$ kernel_{b} = a\left[ \begin{matrix} 1 &amp;amp; 1 &amp;amp; 1 \newline 1 &amp;amp; 1 &amp;amp; 1 \newline 1 &amp;amp; 1 &amp;amp; 1 \end{matrix} \right] $$</description>
    </item>
    
    <item>
      <title>OpenCV-python-1</title>
      <link>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 09 Feb 2020 15:57:11 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>18年结束毕业设计之后，对OpenCV接触很少了。那时使用的是C++，借由最近使用python较多，学习OpenCV-python算是一种温故。本文主要参考了OpenCV-Python图像处理教程以及官方文档。
一、图片 需要注意图片的x，y轴排布，三通道以B-G-R排布，灰度图只有一个通道。
1.1 读取 # 加载灰度图 img = cv2.imread(&#39;lena.jpg&#39;, 0)   参数1：图片的文件名  如果图片放在当前文件夹下，直接写文件名就行了，如&amp;rsquo;lena.jpg&amp;rsquo; 否则需要给出绝对路径，如&amp;rsquo;D:\OpenCVSamples\lena.jpg&amp;rsquo;   参数2：读入方式，省略即采用默认值  cv2.IMREAD_COLOR：彩色图，默认值(1) cv2.IMREAD_GRAYSCALE：灰度图(0) cv2.IMREAD_UNCHANGED：包含透明通道的彩色图(-1)    1.2 显示 # 创建窗口 cv2.namedWindow(&#39;lena2&#39;, cv2.WINDOW_NORMAL)   参数1：窗口名称 参数2：窗口模式  cv2.WINDOW_AUTOSIZE表示窗口大小自适应图片 cv2.WINDOW_NORMAL表示窗口大小可调整    # 显示图片 cv2.imshow(&#39;lena&#39;, img)   参数1：窗口名称 参数2：图片实例  # 保持图片显示 cv2.waitKey(0)    参数：暂停时长，ms
为0时，表示无限长。
  传回按键的ascii码, 如ESC:27、s:115
  1.3 保存 # 保存图片 cv2.</description>
    </item>
    
    <item>
      <title>2019-nCoV疫情数据可视化地图</title>
      <link>https://lil-q.github.io/blog/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9C%B0%E5%9B%BE/</link>
      <pubDate>Sat, 01 Feb 2020 22:41:13 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9C%B0%E5%9B%BE/</guid>
      <description>数据的获取 在学习该博客的数据爬取时发现数据似乎已经不再更新，所以重新在腾讯新闻网站搜索相关数据。
使用time、json和requests获取数据。
import time, json, requests url = &#39;https://view.inews.qq.com/g2/getOnsInfo?name=disease_h5&amp;amp;callback=&amp;amp;_=%d&#39;%int(time.time()*1000) data = json.loads(requests.get(url=url).json()[&#39;data&#39;]) print(data)  可以看到数据如下所示（省略部分内容）：
{&#39;chinaTotal&#39;: {&#39;date&#39;: &#39;02.01&#39;, &#39;confirm&#39;: &#39;11890&#39;, &#39;suspect&#39;: &#39;17988&#39;, &#39;dead&#39;: &#39;259&#39;, &#39;heal&#39;: &#39;269&#39;}, &#39;lastUpdateTime&#39;: &#39;2020-02-01 21:18:01&#39;, &#39;areaTree&#39;: [{&#39;name&#39;: &#39;中国&#39;, &#39;children&#39;: [{&#39;name&#39;: &#39;湖北&#39;, &#39;children&#39;: [...], &#39;total&#39;: {&#39;confirm&#39;: 7153, &#39;suspect&#39;: 0, &#39;dead&#39;: 249, &#39;heal&#39;: 166}, &#39;today&#39;: {&#39;confirm&#39;: 1347, &#39;suspect&#39;: -49, &#39;dead&#39;: 49, &#39;heal&#39;: 15}}, {&#39;name&#39;: &#39;浙江&#39;, &#39;children&#39;: [...], &#39;total&#39;: {&#39;confirm&#39;: 599, &#39;suspect&#39;: 0, &#39;dead&#39;: 0, &#39;heal&#39;: 20}, &#39;today&#39;: {&#39;confirm&#39;: 62, &#39;suspect&#39;: 0, &#39;dead&#39;: 0, &#39;heal&#39;: 7}}, .</description>
    </item>
    
    <item>
      <title>SQL</title>
      <link>https://lil-q.github.io/blog/sql/</link>
      <pubDate>Thu, 16 Jan 2020 13:59:07 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/sql/</guid>
      <description>SQL基础语句快查
原教程地址：http://www.xuesql.cn/
一、定义 1.1 什么是SQL SQL, 全称为Structured Query Language（结构化查询语言)。 要讲SQL就绕不开database(数据库), 平时所说的数据库，一般就是指的 Relational database(关系型数据库)。
大家知道数据库是用来存储大量数据的一种软件，那么SQL呢是用来操作数据里的数据，具体来说SQL可以做数据查询，数据更新，写入数据等等。
1.2 关系型数据库 在学习SQL语法之前有必要解释一下什么是关系型数据库（Relational databases)？数据库由若干张表(Table)组成，这里说的数据Table很像Excel里的表; 正如Excel里的表格，Table也是由 行(rows)和列(columns)组成。
一个Table存储一个类别的数据，每一行是一条数据，每一列是这种数据的一个属性； Table就像一个二维的表格，列(columns)是有限固定的，行(rows)是无限不固定的。
二、查询(SELECT) Select 查询某些属性列（specific columns）的语法。
SELECT column（列名）, another_column, … FROM mytable（表名）;  Select 查询所有列。
SELECT * FROM mytable（表名）;  三、条件查询 (WHERE) 条件查询语法。WHERE
SELECT column, another_column, … FROM mytable WHERE condition AND/OR another_condition AND/OR …;  参考下表：
   Operator（关键字） Condition（意思） SQL Example(例子）     =, !=, &amp;lt; &amp;lt;=, &amp;gt;, &amp;gt;= Standard numerical operators 基础的 大于，等于等比较 col_name !</description>
    </item>
    
    <item>
      <title>查并集</title>
      <link>https://lil-q.github.io/blog/%E6%9F%A5%E5%B9%B6%E9%9B%86-union-find-algorithm/</link>
      <pubDate>Thu, 02 Jan 2020 12:54:02 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E6%9F%A5%E5%B9%B6%E9%9B%86-union-find-algorithm/</guid>
      <description>查并集的进化之路
一、定义 并查集是一种树形的数据结构，顾名思义，它用于处理一些不交集的 合并 及 查询 问题。 它支持两种操作：
 查找（Find）：确定某个元素处于哪个子集； 合并（Union）：将两个子集合并成一个集合。  也就是说，不支持集合的分离、删除。
二、Quick-Find算法 以下图为例，连通关系为[(1,2), (0, 1), (0, 3), (4, 7), (5, 6), (5, 7), (7, 8), (8, 9)]。
首先初始化所有节点，认为它们属于一个组，因此不连通的节点必然就属于不同的组：
   element 0 1 2 3 4 5 6 7 8 9     group number / id 0 1 2 3 4 5 6 7 8 9    输入pair(1, 2)，则将所有group number为0和1的element改为一致（都为0或都为1，这里以较小值为例）。
   element 0 1 2 3 4 5 6 7 8 9     group number / id 0 1 1 3 4 5 6 7 8 9    输入pair(0， 1)，这里就需要把element 1和element 2的group number都改为0，：</description>
    </item>
    
    <item>
      <title>图论</title>
      <link>https://lil-q.github.io/blog/%E5%9B%BE-graph/</link>
      <pubDate>Fri, 27 Dec 2019 17:53:49 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E5%9B%BE-graph/</guid>
      <description>生活不就是一张图吗？
一、定义 图(Graph)用于表示物件与物件之间的关系，是图论的基本研究对象。一张图由一些小圆点（称为顶点或结点）和连结这些圆点的直线或曲线（称为边）组成。
一个图 $G$ 是一个二元组，即序偶 $\langle V,E\rangle$ ，或记作 $G= \langle V,E\rangle$ ，其中 $V$ 是有限非空集合，称为 $G$ 的顶点集， $V$ 中的元素称为顶点或结点； $E$ 称为 $G$ 的边的集合， $\forall e_i \in E$ ，都有 $V$ 中的结点与之对应，称 $e_i$ 为 $G$ 的边。
简单来说，就是图 $G$ 就是一个结点的集合 $V$ 和边的集合 $E$ ，其中任意一条边都可以表示为两个结点之间的关系。若 $e_i\in E$ 表示为 $\langle u,v\rangle$ ，则有 $u\in V , v\in V$ 。
1.1 基本概念 无向图：每条边都是无向边的图。
有向图：每条边都是有向边的图。
有权图：每条边具有一定的权重(weight)，通常是一个数字
无权图：每条边均没有权重，也可以理解为权为 1
连通图：所有的点都有路径相连
非连通图：存在某两个点没有路径相连
邻接：关联于同一条边的两个点 $u$ 和 $v$ 称为邻接的；关联于同一个点的两条边 $e_1$ 和 $e_2$ 是邻接的（或相邻的）。</description>
    </item>
    
    <item>
      <title>树</title>
      <link>https://lil-q.github.io/blog/%E6%A0%91-tree/</link>
      <pubDate>Wed, 04 Dec 2019 21:53:50 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E6%A0%91-tree/</guid>
      <description>之所以叫树是因为他看起来像一棵倒挂的树
一、定义 树（tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 n（n&amp;gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：
 每个节点都只有有限个子节点或无子节点 没有父节点的节点称为根节点 每一个非根节点有且只有一个父节点 除了根节点外，每个子节点可以分为多个不相交的子树 树里面没有环路(cycle)  术语
 节点的度(Degree)：一个节点含有的子树的个数称为该节点的度 树的度(Degree of tree)：一棵树中，最大的节点度称为树的度 叶节点(Leaf)：度为零的节点 分支节点(Branch node)：度不为零的节点 父节点(Parent)：若一个节点含有子节点，则这个节点称为其子节点的父节点 子节点(child)：一个节点含有的子树的根节点称为该节点的子节点 兄弟节点(siblings)：具有相同父节点的节点互称为兄弟节点 层次(level)：从根开始定义起，根为第1层，根的子节点为第2层，以此类推 深度(depth)：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0 高度(height)：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0 节点的祖先(ancestor)：从根到该节点所经分支上的所有节点 森林(forest)：由m（m&amp;gt;=0）棵互不相交的树的集合称为森林  分类
本文将介绍二叉树(Binary tree)、二叉搜索树(Binary search tree)和字典树(Trie)。关于AVL树(AVL tree)、红黑树(Red–black tree)和Ｂ树(B-tree)，不做深入探讨。
这里区分一下完全二叉树、满二叉树、完美二叉树:
 完全二叉树：最后一层的叶子节点均需在最左边 满二叉树：满足完全二叉树性质，树中除了叶子节点，每个节点都有两个子节点 完美二叉树：满足满二叉树性质，树的叶子节点铺满最后一层  二、二叉树 二叉树（英语：Binary tree）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。
# 建一个单节点 class Node(object): def __init__(self, value): self.val = value self.left = None #左节点 self.right = None #右节点 &#39;&#39;&#39; # 建一个二叉树 # 1 # / \ # 2 3 # / \ / \ # 4 5 6 7 &#39;&#39;&#39; root = Node(1) stack = [root] value = 2 for i in range(3): cur = stack.</description>
    </item>
    
    <item>
      <title>堆</title>
      <link>https://lil-q.github.io/blog/%E5%A0%86-heap/</link>
      <pubDate>Sun, 17 Nov 2019 15:49:44 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E5%A0%86-heap/</guid>
      <description>经过努力，最值总会冒上来的！
一、定义  在通常情况下，使用列表储存堆，堆树是一颗完全二叉树，二项堆和斐波那契堆不属于二叉树 堆树中某个节点的值总是不大于或不小于其孩子节点的值 堆树中每个节点的子树都是堆树  当父节点的键值总是大于或等于任何一个子节点的键值时为最大堆。 当父节点的键值总是小于或等于任何一个子节点的键值时为最小堆。 本文以最大堆作为例子，最小堆类似。
二、堆的建立 堆的建立并不建立一个新的树，而是对数组进行原地改动，第一个数（index=0）为完全二叉树的level 0，即根，第二个数和第三个数为level 1，以此类推。
由于数组是升序数组，我们直接得到了最小堆。但是如果要进行升序排序，算法上需要建立最大堆。也就是说，当原数组是升序时，堆排序算法遇到了最坏情况。本文也以这种情况作为例子。
nums=[1,2,3,4,5]  2.1 堆的维护 上图的根节点是1，小于子节点，那么这显然违反了最大堆的性质，这时候需要让该元素在最大堆中逐级下降，维护最大堆的性质。处理一次维护的代码如下：
def adjust_heap(idx, max_len,nums): left = 2 * idx + 1 right = 2 * idx + 2 max_loc = idx if left &amp;lt; max_len and nums[max_loc] &amp;lt; nums[left]: max_loc = left if right &amp;lt; max_len and nums[max_loc] &amp;lt; nums[right]: max_loc = right if max_loc != idx: nums[idx], nums[max_loc] = nums[max_loc], nums[idx] adjust_heap(max_loc, max_len,nums)  2.</description>
    </item>
    
    <item>
      <title>排序算法</title>
      <link>https://lil-q.github.io/blog/%E6%8E%92%E5%BA%8F-sort-%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 16 Nov 2019 19:34:55 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E6%8E%92%E5%BA%8F-sort-%E7%AE%97%E6%B3%95/</guid>
      <description>十种排序算法的python实现及复杂度分析
分类 评价排序算法的几个指标：
 时间复杂度：包括平均时间复杂度、最坏时间复杂度和最好时间复杂度。一般而言，好的性能是$O(nlog_2n)$，坏的性能是$O(n^2)$。对于一个排序理想的性能是O(n)，但平均而言不可能达到。基于比较的排序算法对大多数输入而言至少需要$O(nlog_2n)$。 空间复杂度：内存使用量 稳定性： 稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。 依据排序的方法：插入、交换、选择、合并等等。  本文介绍了以下几种排序，推荐可视化网站visualgo，下文代码都采用数组作为输入。
   排序方法 平均时间复杂度 最坏时间复杂度 最好时间复杂度 空间复杂度 稳定性     冒泡排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 稳定   选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定   插入排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 稳定   堆排序 $O(nlog_2n)$ $O(nlog_2n)$ $O(nlog_2n)$ $O(1)$ 不稳定   归并排序 $O(nlog_2n)$ $O(nlog_2n)$ $O(nlog_2n)$ $O(n)$ 稳定   快速排序 $O(nlog_2n)$ $O(n^2)$ $O(nlog_2n)$ $O(log_2n)$ 不稳定   希尔排序 $O(n^{1.</description>
    </item>
    
  </channel>
</rss>