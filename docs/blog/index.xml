<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on Homeward</title>
    <link>https://lil-q.github.io/blog/</link>
    <description>Recent content in Blogs on Homeward</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>{year} © lil-q</copyright>
    <lastBuildDate>Wed, 16 Sep 2020 10:42:08 +0800</lastBuildDate>
    
	<atom:link href="https://lil-q.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>设计模式：行为型</title>
      <link>https://lil-q.github.io/blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A1%8C%E4%B8%BA%E5%9E%8B/</link>
      <pubDate>Wed, 16 Sep 2020 10:42:08 +0800</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A1%8C%E4%B8%BA%E5%9E%8B/</guid>
      <description>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。
一、迭代器 - Iterator 迭代器使用非常广，它提供了一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。JDK 中使用 Iterable 接口来实现迭代功能：
public interface Iterable&amp;lt;T&amp;gt; { Iterator&amp;lt;T&amp;gt; iterator(); }  Iterable 接口下定义了一个 Iterator() 方法，用来生成一个 iterator，Iterator 接口主要定义了下面两个方法：
public interface Iterator&amp;lt;E&amp;gt; { boolean hasNext(); E next(); }  在使用时，先创建一个迭代器，通过 hasNext() 判断其是否还有下一个值并使用 next() 获取。JDK 中的 Collection 继承自 Iterable，所以 Collection 下的实现类都是可迭代的。Map 的迭代通过其下的 keySet 和 entrySet 两个 set 实现，Set 继承自 Collection，所以也是可迭代的。
1.1 叫号器 运用迭代器可以实现一个简单的叫号器（queue management system，qms），首先模仿 JDK 定义下面两个接口：
interface ManagementSystem&amp;lt;E&amp;gt; { Caller&amp;lt;E&amp;gt; createCaller(); } interface Caller&amp;lt;E&amp;gt; { boolean hasNext(); E next(); }  ManagementSystem 管理系统接口需要定义一个获取叫号器 caller 的方法，这里 Caller 和 Iterator 功能相同，通过 hasNext() 判断其是否还有下一个号码并使用 next() 获取。</description>
    </item>
    
    <item>
      <title>持久层与持久层框架</title>
      <link>https://lil-q.github.io/blog/mybatis/</link>
      <pubDate>Mon, 14 Sep 2020 12:00:08 +0800</pubDate>
      
      <guid>https://lil-q.github.io/blog/mybatis/</guid>
      <description>为了保存数据，需要持久层；为了实现持久层，需要数据库；为了管理数据库，需要数据库管理系统；为了操作数据库管理系统，需要持久层框架。
一、持久层 储存在内存之上的数据在断电后就会清除，与之相对的，储存在硬盘中的数据可以长时间、安全的保存，称之为持久层。
企业应用中的数据（各种订单数据、客户数据、库存数据等）十分重要，所以需要把数据持久化。持久化可以通过很多方式，写文件和数据库都可以，一般会把数据持久化到数据库中，因为可以很方便的查询、统计和分析，而且数据库 ACID 特性中的持久性（durability）就是针对的持久层。
二、JDBC 对于 Java，最开始是使用 JDBC 来进行数据库管理的。Java数据库连接（Java Database Connectivity，JDBC）是 Java 提供的一个操作数据库的 API。它是由各种数据库厂商提供类和接口组成的数据库驱动，为多种数据库提供统一访问，使用数据库时只需要调用 JDBC 接口就行了，大致的步骤如下：
public class JDBCTest { // JDBC driver name and database URL static final String JDBC_DRIVER = &amp;quot;com.mysql.cj.jdbc.Driver&amp;quot;; static final String DB_URL = &amp;quot;jdbc:mysql://localhost:port/DB_name?...&amp;quot;; // Database credentials static final String USER = &amp;quot;root&amp;quot;; static final String PASS = &amp;quot;password&amp;quot;; public static void main(String[] args) { Connection conn = null; Statement stmt = null; try { //STEP 1: Register JDBC driver Class.</description>
    </item>
    
    <item>
      <title>Spring Framework</title>
      <link>https://lil-q.github.io/blog/spring/</link>
      <pubDate>Wed, 09 Sep 2020 18:07:37 +0800</pubDate>
      
      <guid>https://lil-q.github.io/blog/spring/</guid>
      <description>&amp;ldquo;From configuration to security, web apps to big data—whatever the infrastructure needs of your application may be, there is a Spring Project to help you build it. Start small and use just what you need—Spring is modular by design.&amp;rdquo;
 Spring 是一个生态体系，也可以说是技术体系，是集大成者，它包含了 Spring Framework、Spring Boot、Spring Cloud等。平时常说的 Spring 其实是指 Spring Framework，它是整个 spring 生态的基石。
一、Spring Framework  &amp;ldquo;Provides core support for dependency injection, transaction management, web apps, data access, messaging, and more.</description>
    </item>
    
    <item>
      <title>面向对象</title>
      <link>https://lil-q.github.io/blog/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Mon, 07 Sep 2020 18:54:03 +0800</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <description>面向对象程序设计（Object-Oriented Programming，OOP）是一种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的资料。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。
一、特性 1.1 封装 利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。
优点：
 减少耦合：可以独立地开发、测试、优化、使用、理解和修改； 减轻维护的负担：可以更容易被理解，并且在调试的时候可以不影响其他模块； 有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能； 提高软件的可重用性； 降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的。  1.2 继承 继承是指在某种情况下，一个类会有子类。子类比原本的类（称为父类）要更加具体化。java 只允许单继承，一个子类只能继承自一个父类，使用extends关键字。也就是说对于一个类，只能认为它属于另一个大类，如果它需要实现其他功能时，则还要实现功能接口（interface），使用implements关键字。
1.3 多态 C++ 中的虚函数就是为了多态。Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是 Java 的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。
方法的重写（Override）和重载（Overload）是 java 多态性的不同表现。重写解决的是子类与父类针对同一方法需要采取不同实现方式的问题，通过 JVM 在类加载时（解析阶段）的动态绑定机制实现。重载是面向使用者的，针对不同的调用方式返回不同的结果。
二、设计原则 错误的设计类会带来很多问题，比如下面的悖论（为了方便理解，下文中长方形指代长宽不等的矩形）。
2.1 正方形不是矩形？ 这个悖论的简单实现如下：写出矩形类，定义长和宽，并写出长宽的 setter 方法和一个获取面积的方法：
public class Rectangle { int length; int width; public void setLength(int length) { this.length = length; } public void setWidth(int width) { this.width = width; } public int getArea() { return length * width; } }  写出子类正方形继承父类矩形，由于正方形的长宽是相同的，重写两个 setter 方法保证长宽一致：</description>
    </item>
    
    <item>
      <title>HTTP &amp; RESTful</title>
      <link>https://lil-q.github.io/blog/http-restful/</link>
      <pubDate>Thu, 23 Jul 2020 09:46:01 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/http-restful/</guid>
      <description>HyperText Transfer Protocol &amp;amp; REpresentational State Transfer
一、概述 超文本传输协议（HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。
表现层状态转换（REST）本身并没有创造新的技术、组件或服务，而隐藏在 RESTful 背后的理念就是使用 Web 的现有特征和能力， 更好地使用现有 Web 标准中的一些准则和约束。虽然 REST 本身受 Web 技术的影响很深， 但是理论上 REST 架构风格并不是绑定在 HTTP 上，只不过目前 HTTP 是唯一与 REST 相关的实例。
1.1 URI 统一资源标识符（Uniform Resource Identifier，URI）是一个用于标识某一互联网资源名称的字符串。URI的最常见的形式是统一资源定位符（Uniform Resource Locator，URL），经常指定为非正式的网址。更罕见的用法是统一资源名称（Uniform Resource Name，URN），其目的是通过提供一种途径。用于在特定的名字空间资源的标识，以补充网址。在RESTful架构中 URI 不应该有动词，动词应该放在HTTP协议中。
资源是一种信息实体，它可以有多种外在表现形式。“资源” 具体呈现出来的形式，叫做它的 &amp;ldquo;表现层&amp;rdquo;（Representation）。URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的 &amp;ldquo;.html&amp;rdquo; 后缀名是不必要的，因为这个后缀名表示格式，属于 &amp;ldquo;表现层&amp;rdquo; 范畴，而 URI 应该只代表 &amp;ldquo;资源&amp;rdquo; 的位置。它的具体表现形式，应该在 HTTP 请求的头信息中用 Accept 和 Content-Type 字段指定，这两个字段才是对 &amp;ldquo;表现层&amp;rdquo; 的描述。
因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个 URI。版本号可以在 HTTP 请求头信息的 Accept 字段中进行区分（参见Versioning REST Services）：
1.2 如何理解 RESTful REST 本身受 Web 技术的影响很深，可以借助 WEB 来理解 RESTful。网站是采用客户端/服务器模式，建立在分布式体系上，通过互联网通信，具有高延时（high latency）、高并发等特点的一种软件。表现层（Representation）的含义是把资源具体的形式呈现出来。表现层上的网站交互就是客户端获取或修改服务器端储存的资源，而这些获取或修改的操作就是资源的状态转换。具体的实现很简单</description>
    </item>
    
    <item>
      <title>MySQL</title>
      <link>https://lil-q.github.io/blog/mysql/</link>
      <pubDate>Fri, 17 Jul 2020 16:16:51 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/mysql/</guid>
      <description>/maɪ ˌɛskjuːˈɛl/
一、索引 优势：减少 I/O 次数，加快检索速度；根据索引分组和排序，可以加快分组和排序；
劣势：索引本身也是表，因此会占用存储空间，一般来说，索引表占用的空间的数据表的1.5倍；索引表的维护和创建需要时间成本，这个成本随着数据量增大而增大；构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表。
常见的索引类型有：主键索引、唯一索引、普通索引、全文索引、组合索引
（1）主键索引：即主索引，根据主键 pk_clolum（length）建立索引，不允许重复，不允许空值
ALTER TABLE &#39;table_name&#39; ADD PRIMARY KEY pk_index(&#39;col&#39;)；  （2）唯一索引：用来建立索引的列的值必须是唯一的，允许空值
ALTER TABLE &#39;table_name&#39; ADD UNIQUE index_name(&#39;col&#39;)；  （3）普通索引：用表中的普通列构建的索引，没有任何限制
ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col&#39;)；  （4）全文索引：用大文本对象的列构建的索引
ALTER TABLE &#39;table_name&#39; ADD FULLTEXT INDEX ft_index(&#39;col&#39;)；  （5）组合索引：用多个列组合构建的索引，这多个列中的值不允许有空值
ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col1&#39;,&#39;col2&#39;,&#39;col3&#39;)；  1.1 实现原理 1. B+ 数 B 树是一种自平衡的树，能够保持数据有序。当描述一颗 B 树时需要指定它的阶数，阶数表示了一个结点最多有多少个孩子结点，一般用字母 m 表示阶数。当 m 取 2 时，就是我们常见的二叉搜索树。
B+ 树与 B 树通常用于数据库和操作系统的文件系统中。特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入，这与二叉树恰好相反，具体请参考[2]。</description>
    </item>
    
    <item>
      <title>数据库原理</title>
      <link>https://lil-q.github.io/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Thu, 16 Jul 2020 20:30:14 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>就像操作系统屏蔽了硬件访问复杂性那样，数据库屏蔽了数据访问的复杂性。
一、事务 事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。
1.1 ACID 1. 原子性 事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。
回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。
2. 一致性 数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。
3. 隔离性 一个事务所做的修改在最终提交以前，对其它事务是不可见的。
4. 持久性 一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。
系统发生奔溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。
1.2 关系   一致性：保证事务的执行结果正确：
 无并发：事务串行执行，隔离性一定能够满足；只需满足原子性。 有并发：多个事务并行执行，事务不仅要满足隔离性；还需要满足原子性。    持久性：应对系统崩溃。
  二、并发一致性问题 在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。
1. 丢失修改 丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。
例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。
2. 读脏数据 读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。
例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。
3. 不可重复读 不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。
例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</description>
    </item>
    
    <item>
      <title>Java：虚拟机</title>
      <link>https://lil-q.github.io/blog/java-%E8%99%9A%E6%8B%9F%E6%9C%BA/</link>
      <pubDate>Tue, 07 Jul 2020 11:17:47 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java-%E8%99%9A%E6%8B%9F%E6%9C%BA/</guid>
      <description>一、内存区域 1.1 程序计数器 程序计数器是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都依赖这个计数器。记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。
1.2 Java 虚拟机栈 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
该区域可能抛出以下异常：
 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常； 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。  1.3 本地方法栈 本地方法栈与虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。
本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。
1.4 堆 所有对象都在这里分配内存，是垃圾收集的主要区域（&amp;ldquo;GC 堆&amp;rdquo;）。
现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：
 新生代（Young Generation） 老年代（Old Generation）  堆不需要连续内存，当前主流的 Java 虚拟机都是按照可扩展来实现的（通过参数 -Xmx 和 -Xms 设定），增加失败会抛出 OutOfMemoryError 异常。
栈和堆的区别如下：
 功能：栈的功能是运行，堆的功能是储存； 共享性：栈是线程隔离的，堆是线程共享的； 异常错误 ：栈可能报出 StackOverflowError 异常和 OutOfMemoryError 异常，堆报出后者； 空间：栈的空间连续，堆的空间不连续，栈的空间远小于堆。  1.5 方法区 用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。
对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。
HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.</description>
    </item>
    
    <item>
      <title>设计模式：创建型</title>
      <link>https://lil-q.github.io/blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%9E%8B/</link>
      <pubDate>Tue, 12 May 2020 23:30:13 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%9E%8B/</guid>
      <description>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。
一、单例 - Singleton 单例模式属于创建型设计模式，确保一个类只有一个实例，并提供该实例的全局访问点。一般有两种情况需要用到单例：
 资源共享：节约系统资源，不需要频繁创建和销毁的对象，如日志文件，应用配置等； 资源控制：方便资源之间的互相通信，如线程池等。  以下是一些常见的单例应用场景：
 Windows 的任务管理器（Task Manager）和回收站（Recycle Bin）在整个系统运行过程中，只维护仅有的一个实例。 网站的计数器，一般也是采用单例模式实现，否则难以同步。 在操作系统中，打印池（Print Spooler）是一个用于管理打印任务的应用程序，通过打印池用户可以删除、中止或者改变打印任务的优先级，在一个系统中只允许运行一个打印池对象，如果重复创建打印池则抛出异常。  实现: 使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。
1.1 饿汉式 饿汉式是线程安全的，它采取直接实例化 uniqueInstance 的方式。
这种方式比较常用，它基于 classloader 机制避免了多线程的同步问题，但容易产生垃圾对象(丢失了延迟实例化带来的节约资源的好处)。
public class Singleton { // 急切的创建了uniqueInstance, 所以叫饿汉式 private static Singleton uniqueInstance = new Singleton(); private Singleton(){ } public static Singleton newInstance(){ return uniqueInstance; } // 如果我们只是想调用 Singleton.getStr(...)， // 本来是没有必要生成 Singleton 实例的，但是饿汉式已经生成了 public static String getStr(String str) {return &amp;quot;hello&amp;quot; + str;} }  1.</description>
    </item>
    
    <item>
      <title>操作系统</title>
      <link>https://lil-q.github.io/blog/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Sun, 10 May 2020 00:08:33 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
      <description>操作系统是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。
一、概述 1.1 基础特性 批处理系统有着高资源利用率和系统吞吐量；分时系统能获得及时响应；实时系统具有实时特征。除此之外，操作系统还具有并发、共享、虚拟和异步四个基本特性。
1. 并发 并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。
并行是物理意义上的，需要硬件支持，如多流水线、多核处理器或者分布式计算系统，而并发是逻辑意义上的。
操作系统通过引入进程和线程，使得程序能够并发运行。
2. 共享 共享又称资源复用，是指系统中的资源可以被多个并发进程共同使用。
有两种共享方式：互斥共享和同时共享。
互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。
3. 虚拟 虚拟技术把一个物理实体转换为多个逻辑实体。
主要有两种虚拟技术：时分复用技术和空分复用技术。
多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。
虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。
4. 异步 异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。
1.2 主要功能 1. 进程管理 处理机的分配和运行都是以进程为基本单位。
 进程控制：创建进程和终止已结束进程； 进程同步：进程互斥方式（如加锁）和进程同步方式（如信号量机制）； 进程通信：直接通信方式（如源进程利用发送命令直接把消息挂到目标进程的消息队列上）； 调度：作业调度和进程调度； 死锁处理。  2. 内存管理 为多道程序的运行提供良好的环境，提高存储器的利用率。
 内存分配：静态分配方式和动态分配方式； 地址映射； 内存保护与共享； 虚拟内存等。  3. 文件管理 为用户进程分配 I/O 设备，提高 CPU 和 I/O 设备的利用率。
 文件存储空间的管理； 目录管理； 文件读写管理和保护。  4. 设备管理 完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。
 缓冲管理； 设备分配； 设备处理； 虛拟设备。  1.</description>
    </item>
    
    <item>
      <title>计算机网络</title>
      <link>https://lil-q.github.io/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Tue, 05 May 2020 19:30:17 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</guid>
      <description>网络把主机连接起来，而互连网（internet）是把多种不同的网络连接起来，因此互连网是网络的网络。
一、概述 1. 主机之间的通信方式   客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。
  对等（P2P）：不区分客户和服务器。
  2. 报文交换  电路交换：整个报文的比特流连续地从源点直达终点。 报文交换：整个报文存储到相邻结点并查找转发表不断跳转。 分组交换：单个分组存储到相邻结点并查找转发表不断跳转。  3. 时延 总时延 = 排队时延 + 处理时延 + 发送时延 + 传播时延：
（1）排队时延
分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。
（2）处理时延
主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。
（3）发送时延
主机或路由器传输数据帧所需要的时间。
（4）传播时延
电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。
4. 体系结构   应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。
  传输层 ：为进程提供通用的数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。
以上为端到端，以下为点到点：
  网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。
  数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。
  物理层 ：考虑如何在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。
  （1）协议</description>
    </item>
    
    <item>
      <title>Morris 算法</title>
      <link>https://lil-q.github.io/blog/morris%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 01 May 2020 14:51:08 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/morris%E7%AE%97%E6%B3%95/</guid>
      <description>morris 遍历利用的是树的叶节点左右孩子为空（树的大量空闲指针），实现空间开销的极限缩减。对于二叉树的遍历，通常采用递归或者利用栈的迭代方法，两者的空间复杂度都为 $O\left ( N \right )$。morris 遍历可以将非递归遍历中的空间复杂度降为 $O\left ( 1 \right )$。
前序遍历 以前序遍历为例子，比如leecode上的144. 二叉树的前序遍历，先给出代码：
class Solution { public List&amp;lt;Integer&amp;gt; preorderTraversal(TreeNode root) { List&amp;lt;Integer&amp;gt; res = new LinkedList&amp;lt;&amp;gt;(); TreeNode cur = root; // 当前处理节点 TreeNode tail = null; // tail记录当前节点左子树的最右节点 while (cur != null) { tail = cur.left; if (tail != null) { // 找到tail的位置 while (tail.right != null &amp;amp;&amp;amp; tail.right != cur) { tail = tail.right; } // tail没有连接，说明cur节点还没处理，输出这个节点 if (tail.</description>
    </item>
    
    <item>
      <title>Java：并发</title>
      <link>https://lil-q.github.io/blog/java-%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Tue, 28 Apr 2020 19:37:01 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java-%E5%B9%B6%E5%8F%91/</guid>
      <description>计算机的运算速度与它的存储和通信子系统的速度差距太大，大量的时间都花费在磁盘 I/O、网络通信或者数据库访问上。高效并发能能更好的利用计算机的性能。
一、硬件的效率和一致性 由于计算机的存储设备与处理器的运算速度有着几个数量级的差距，所以现代计算机系统都不得不加入一层或多层读写速度尽可能接近处理器运算速度的高速缓存（ Cache）来作为内存与处理器之间的缓冲：将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。
基于高速缓存的存储交互很好地解决了处理器与内存速度之间的矛盾，但是也为计算机系统带来更高的复杂度，它引入了一个新的问题：缓存一致性（ Cache Coherence）。在多路处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（ Main Memory），这种系统称为共享内存多核系统（ Shared Memory Multiprocessors System），如下图所示。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。
为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作。
除了増加高速缓存之外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，让指令的执行能够尽可能的并行起来。处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java 虚拟机的即时编译器中也有指令重排序（ Instruction Reorder）优化。
即使是单线程，指令重排仍然能加速执行，因为一个非原子操作指令也会涉及到很多步骤（取指令、指令译码、执行指令、访存取数、结果写回），每个步骤可能会用到不同的寄存器，CPU 使用了流水线技术，也就是说，CPU 有多个功能单元，一条指令也分为多个单元，那么第一条指令执行还没完毕，就可以执行第二条指令，前提是这两条指令功能单元相同或类似，所以一般可以通过指令重排使得具有相似功能单元的指令接连执行来减少流水线中断的情况。
二、Java 内存模型 Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。Java 内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。
 此处的变量（Variables）与 Java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。
 Java 内存模型规定了所有的变量都存储在主内存（ Main Memory，与硬件的主内存同名，但物理上它仅是虚拟机内存的一部分）。每条线程还有自己的工作内存（ Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成（如果局部变量是一个 reference 类型，它引用的对象在 Java 堆中可被各个线程共享，但是 reference 本身在 Java 栈的局部变量表中是线程私有的）。
2.1 内存间交互操作 Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于 double 和 long 类型的变量来说， load、 store、read 和 write 操作在某些平台上允许有例外）。
 lock：作用于主内存的变量，标识为一条线程独占。 unlock：作用于主内存的变量，释放处于锁定状态的变量。 read：作用于主内存的变量，传输到工作内存中。 load：作用于工作内存的变量，在 read 之后执行，把值放入工作内存的变量副本中。 use：作用于工作内存的变量，传递给执行引擎。 assign：作用于工作内存的变量，把一个从执行引擎接收到的值赋给工作内存的变量。 store：作用于工作内存的变量，把一个变量的值传送到主内存中。 write：作用于主内存的变量，在 store 之后执行，把值放入主内存的变量中。  2.</description>
    </item>
    
    <item>
      <title>贪心算法</title>
      <link>https://lil-q.github.io/blog/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 22 Apr 2020 20:42:19 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</guid>
      <description>一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。
一、概述 贪心算法（greedy algorithm），又称贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。比如在旅行推销员问题中，如果旅行员每次都选择最近的城市，那这就是一种贪心算法。
贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。
贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。
贪心法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码……对于其他问题，贪心法一般不能得到我们所要求的答案。一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。
二、流程  创建数学模型来描述问题。 把求解的问题分成若干个子问题。 对每一子问题求解，得到子问题的局部最优解。 把子问题的解局部最优解合成原来解问题的一个解。  三、题解 回溯算法，动态规划和贪心算法其实是循序渐进的。回溯算法即是暴力的枚举，每一步对所有可能都进行计算，计算到达终点即返回，每一步返回后都要把状态回归到之前的状态。回溯算法的痛点是他有很多重复的计算，解决的办法是引入备忘录，备忘录记录了每一步的结果，这其实就是子问题的最优解，动态规划由此产生。所以使用动态规划时必须要满足无后效性，子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。如果一个问题没有重叠子问题，那就只能使用回溯算法，比如N皇后问题。
对于有些问题，我们通过建立数学模型之后明确知道了子问题的最优解，那么就不需要枚举各种情况了。比如有 5 元，2 元和 1 元三种硬币无限个，求用这些硬币兑换 x 元的最少硬币个数。解决这个问题总是先考虑最大面额的硬币，并不需要枚举。但是对于 5 元，4 元和 1 元这三个面额，贪心算法并不能得出最优解。
加油站 leetcode 134. 加油站：在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。
说明:
 如果题目有解，该答案即为唯一答案。 输入数组均为非空数组，且长度相同。 输入数组中的元素均为非负数。  示例:
输入: gas = [1,2,3,4,5] cost = [3,4,5,1,2] 输出: 3  这个问题的子问题是从第 i 个加油站出发，到达每个站的油量大于等于 0 ，则返回这个节点。
遍历所有节点，cur记录当前节点油箱内剩余油量，p记录可能的起点。如果cur小于 0 ，那么这个节点包括之前的节点都不可能是起点，将cur置 0 ，p置为下一个节点。</description>
    </item>
    
    <item>
      <title>Java：I/O</title>
      <link>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E5%85%AD/</link>
      <pubDate>Sat, 04 Apr 2020 14:13:57 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E5%85%AD/</guid>
      <description>一、IO 1.1 File  创建File f = new File(&amp;quot;C:\\Windiws\\...&amp;quot;)对象本身不涉及IO操作，并不会导致任何磁盘操作； 可以获取路径／绝对路径／规范路径：getPath()/getAbsolutePath()/getCanonicalPath()； 可以获取目录的文件和子目录：list()/listFiles()； boolean mkdir()：创建当前File对象表示的目录； boolean mkdirs()：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来； boolean delete()：删除当前File对象表示的目录，当前目录必须为空才能删除成功。  Java I/O 使用了装饰者模式来实现。以 InputStream 为例，
 InputStream 是抽象组件； FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作； FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。  实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。
1.2 输入 InputStream就是Java标准库提供的最基本的输入流。它位于java.io这个包里。java.io包提供了所有同步IO的功能。
InputStream并不是一个接口，而是一个抽象类，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是int read()：
public abstract int read() throws IOException;  这个方法会读取输入流的下一个字节，并返回字节表示的int值（0~255）。如果已读到末尾，返回-1表示不能继续读取了。
FileInputStream是InputStream的一个子类，能从文件流中读取数据。使用try(resource)可以保证InputStream正确关闭（因为InputStream和OutputStream都实现了java.lang.AutoCloseable接口）。
public void readFile() throws IOException { try (InputStream input = new FileInputStream(&amp;quot;src/readme.txt&amp;quot;)) { int n; while ((n = input.</description>
    </item>
    
    <item>
      <title>Java：Map</title>
      <link>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E4%BA%94/</link>
      <pubDate>Thu, 02 Apr 2020 15:37:30 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E4%BA%94/</guid>
      <description>一、Map Map 是一种键-值映射表，当我们调用 put(K key, V value) 方法时，就把 key 和 value 做了映射并放入 Map。当我们调用 V get(K key) 时，就可以通过 key 获取到对应的 value。如果 key 不存在，则返回 null。和 List 类似，Map 也是一个接口，最常用的实现类是 HashMap。
 TreeMap：基于红黑树实现。 HashMap：基于哈希表实现。 HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。  1.1 Map 遍历 要遍历 key 可以使用 for each 循环遍历 Map 实例的 keySet() 方法返回的 Set 集合，它包含不重复的 key 的集合：
for (String key : map.keySet()) {...}  同时遍历 key 和 value 可以使用 for each 循环遍历 Map 对象的 entrySet() 集合，它包含每一个 key-value 映射：</description>
    </item>
    
    <item>
      <title>Java：Collection</title>
      <link>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E5%9B%9B/</link>
      <pubDate>Mon, 30 Mar 2020 18:34:55 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E5%9B%9B/</guid>
      <description>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。【以下内容源码基于 Java 13】
一、Collection 二、List List 接口有几个主要的接口方法：
 在末尾添加一个元素：void add(E e)； 在指定索引添加一个元素：void add(int index, E e)； 删除指定索引的元素：int remove(int index)； 删除某个元素：int remove(Object e)； 获取指定索引的元素：E get(int index)； 获取链表大小（包含元素的个数）：int size()。  List 接口允许我们添加重复的元素，即 List 内部的元素可以重复，List 还允许添加 null。调用 List.of()，它返回的是一个只读 List：
List&amp;lt;Integer&amp;gt; list = List.of(1, 2, 5);  但是 List.of() 方法不接受 null 值，如果传入 null，会抛出 NullPointerException 异常。
2.1 List 遍历 List 的遍历采用了迭代器的设计模式：
Iterable 接口声明如下：
public interface Iterable&amp;lt;T&amp;gt; { Iterator&amp;lt;T&amp;gt; iterator(); }  Iterator 接口声明如下：</description>
    </item>
    
    <item>
      <title>Java：反射和泛型</title>
      <link>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E4%B8%89/</link>
      <pubDate>Fri, 27 Mar 2020 22:45:02 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E4%B8%89/</guid>
      <description>一、反射 由于 JVM 为每个加载的类创建了对应的 Class 实例，并在实例中保存了该类的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个 Class 实例，我们就可以通过这个 Class 实例获取到该实例对应的类的所有信息。这种通过 Class 实例获取类信息的方法称为反射（Reflection）。
Java 反射主要提供以下功能：
 在运行时判断任意一个对象所属的类； 在运行时构造任意一个类的对象； 在运行时判断任意一个类所具有的成员变量和方法（甚至可以调用 private 方法）； 在运行时调用任意一个对象的方法。  重点：是运行时而不是编译时。
1.1 Class 类 获取一个类的 Class 实例有三个方法：
（1）直接通过一个类的静态变量 class 获取：
Class&amp;lt;?&amp;gt; cls = String.class;  （2）如果我们有一个实例变量，可以通过该实例变量提供的 getClass() 方法获取：
String s = &amp;quot;Hello&amp;quot;; Class&amp;lt;?&amp;gt; cls = s.getClass();  （3）如果知道一个类的完整类名，可以通过静态方法 Class.forName() 获取：
Class&amp;lt;?&amp;gt; cls = Class.forName(&amp;quot;java.lang.String&amp;quot;);  Class.forName() 加载类时默认会初始化，而 ClassLoader.loadClass() 默认不会初始化，只完成了类加载中的第一步加载。
注意 Class 实例 == 比较和 instanceof 的差别：
Integer n = new Integer(123); boolean b1 = n instanceof Integer; // true，因为n是Integer类型 boolean b2 = n instanceof Number; // true，因为n是Number类型的子类 boolean b3 = n.</description>
    </item>
    
    <item>
      <title>Java：面向对象和异常处理</title>
      <link>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E4%BA%8C/</link>
      <pubDate>Mon, 23 Mar 2020 14:08:20 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E4%BA%8C/</guid>
      <description>一、面向对象 Java 是一种面向对象的编程语言。面向对象编程，英文是 Object-Oriented Programming，简称 OOP。
1.1 权限修饰符     本类 同一个包下（子类和无关类） 不同包下（子类） 不同包下（无关类）     public √ √ √ √   protected √ √ √ ×   default √ √ × ×   private √ × × ×    一个 .java 文件只能包含一个 public 类，但可以包含多个非 public 类。如果有 public 类，文件名必须和 public 类的名字相同。
1.2 继承 如果父类没有默认的构造方法，子类就必须显式调用 super() 并给出参数以便让编译器定位到父类的一个合适的构造方法。
子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。
 向上转型（upcasting）：一个子类类型安全地变为父类类型的赋值。 向下转型（downcasting）：一个父类类型强制转型为子类类型。  向上转型只能够调用子类重写的方法；找回向上转型时丢失的子类扩展方法。instanceof 判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为 null，那么对任何 instanceof 的判断都为 false。</description>
    </item>
    
    <item>
      <title>Java：基础</title>
      <link>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Fri, 20 Mar 2020 19:33:14 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80/</guid>
      <description>Java Virtual Machine，JVM：
整个 Java 实现跨平台的最核心的部分，所有的 Java 程序会首先被编译为 .class 的类文件，这种类文件可以在虚拟机上执行，也就是说 class 并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。
  Java Runtime Environment，JRE：
Java 运行环境。在 JDK 的安装目录里你可以找到 jre 目录，里面有两个文件夹 bin 和 lib ，在这里可以认为 bin 里的就是 jvm，lib 中则是 jvm 工作所需要的类库，而 bin 和 lib 和起来就称为 JRE。
  Java Development Kit，JDK：
Java 开发工具包，是支持 Java 程序开发的最小环境。JDK 对比 JRE 多了 Java language 和工具 API。
  一、数据类型 1.1 基本类型  byte/8 [-128 ~ 127] char/16 short/16 [-32768 ~ 32767] int/32 [-2147483648 ~ 2147483647] float/32 long/64 [-9223372036854775808 ~ 9223372036854775807] double/64 boolean/~  Java 语言对布尔类型的存储并没有做规定，因为理论上存储布尔类型只需要 1 bit，但是通常 JVM 内部会把 boolean 表示为 4 字节整数，为了节省内存而表示为更小的类型可能会在之后处理时带来不必要的麻烦。</description>
    </item>
    
    <item>
      <title>回溯算法</title>
      <link>https://lil-q.github.io/blog/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 08 Mar 2020 13:12:02 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</guid>
      <description>“想回到过去，试着让故事继续”
回溯 回溯（backtracking）是暴力搜索法中的一种。
对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题。
 约束满足问题：在解决约束满足问题时，我们逐步构造更多的候选解，并且在确定某一部分候选解不可能补全成正确解之后放弃继续搜索这个部分候选解本身及其可以拓展出的子候选解，转而测试其他的部分候选解。
 回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步执行的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将撤销上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案，找到答案即算法运行至终止条件。
回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：
 找到一个可能存在的正确的答案 在尝试了所有可能的分步方法后宣告该问题没有答案  在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。
典型的回溯 leetcode 46. 全排列：给定一个没有重复数字的序列，返回其所有可能的全排列。
示例:
输入: [1,2,3] 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]  用比较通用的回溯算法可以这样解答：
class Solution: def permute(self, nums: List[int]) -&amp;gt; List[List[int]]: size = len(nums) res = [] # 记录已经选择过的数 visited = set() def backtrack(numList, visited): # 当所有数字都选完了，终止 if len(visited) == size: res.append(numList[:]) # 注意深拷贝和浅拷贝的问题 return # 遍历所有可能的选择 for i in range(size): # 如果这个数已在前面出现过了，跳过 if i in visited: continue visited.</description>
    </item>
    
    <item>
      <title>OpenCV-python：图像梯度与边缘检测</title>
      <link>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/</link>
      <pubDate>Sat, 22 Feb 2020 17:51:07 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/</guid>
      <description>一、图像梯度 在谈及梯度之前需要先找到函数，图片是二维的离散函数，二维意味着需要找到求梯度的方向，离散意味着对于图片的梯度不是导数而是差分。下式就是按照水平从左到右方向每隔一个像素点求差分：
$$ \Delta f\left ( i,j \right )=f\left ( i+1,j \right )-f\left ( i,j \right ) $$
1.1 Prewitt operator 将上式用卷积的方式处理是就可以是有下面这个卷积核（Prewitt 边缘检测算子）：
$$ Prewitt = \frac{1}{9}\left[ \begin{matrix} -1 &amp;amp; 0 &amp;amp; 1 \newline -1 &amp;amp; 0 &amp;amp; 1 \newline -1 &amp;amp; 0 &amp;amp; 1 \end{matrix} \right] $$
使用 Prewitt 算子处理后，值比较高的像素点意味着梯度较大，就是更解决边缘；值比较低的像素点意味着梯度较小，就是更解决平滑表面。
1.2 Sobel operator 考虑到对正在处理行的数据需要更多的重视，对 Prewitt 边缘检测算子改进就形成了 Sobel 边缘检测算子：
$$ Sobel_{x} = \frac{1}{9}\left[ \begin{matrix} -1 &amp;amp; 0 &amp;amp; 1 \newline -2 &amp;amp; 0 &amp;amp; 2 \newline -1 &amp;amp; 0 &amp;amp; 1 \end{matrix} \right] $$</description>
    </item>
    
    <item>
      <title>OpenCV-python：亮度与对比度</title>
      <link>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/</link>
      <pubDate>Thu, 20 Feb 2020 14:14:07 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/</guid>
      <description>一、OpenCV与NumPy OpenCV 读取一张图片，返回的实际上是一个numpy.ndarray类。所以一些对numpy.ndarray的操作可以直接对cv2.imread()返回的对象使用。
import cv2 import numpy as np img = cv2.imread(&#39;connelly.jpg&#39;) print(type(img)) # &amp;lt;class &#39;numpy.ndarray&#39;&amp;gt; rows, cols = img.shape[:2] print(rows, cols) # 210 270  1.1 访问和修改像素值 根据像素值的行和列坐标可以访问特定像素点。对于 BGR 图像，它返回一个蓝色、绿色、红色值数组。灰度图像，只返回相应的亮度。
px = img[100, 120] img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) px_gray = img_gray[100, 120] print(px) # [130 131 181] print(px_gray) # 146  可以用同样的方式修改像素值。
img[100, 120] = [255,255,255]  NumPy 是一个用于快速数组计算的优化库。因此，使用原生 python 的数组简单地访问每个像素值，并修改它将非常缓慢，不推荐这种方法。
上述方法通常用于选择数组区域，例如前 5 行和最后 3 列。对于单个像素访问，但用 NumPy 数组的方法、array.tem()和array.itemset()会更适合。因为它总是返回一个标量。因此，如果想访问所有的 B，G，R 值，你需要为所有通道分别调用array.</description>
    </item>
    
    <item>
      <title>OpenCV-python：图像混合与形态学</title>
      <link>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/</link>
      <pubDate>Wed, 19 Feb 2020 13:00:33 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/</guid>
      <description>一、图像混合 1.1 图像混合 图像混合cv2.addWeighted()要求两幅图片的形状（高度/宽度/通道数）必须相同，$ \omega_{1} $ 和 $ \omega_{2} $ 分别为两幅图像的权重，b 则是一个偏置：
$$ dst = \omega_{1}\times img1+\omega_{2}\times img2 + b $$
img1 = cv2.imread(&#39;img1_name.jpg&#39;) img2 = cv2.imread(&#39;img2_name.png&#39;) res = cv2.addWeighted(img1, 0.6, img2, 0.4, 0)  特别的，当 $ \omega_{1} $ 和 $ \omega_{2} $ 都为1，b 为 0 时，就是两张图片相加。可以用cv2.add()函数。numpy 中可以直接用res = img1 + img2相加，但这两者的结果并不相同：
x = np.uint8([250]) y = np.uint8([10]) print(cv2.add(x, y)) # 250 + 10 = 260 =&amp;gt; 255 --255封顶 print(x + y) # 250 + 10 = 260 % 256 = 4 --会溢出  1.</description>
    </item>
    
    <item>
      <title>OpenCV-python：滤波和阈值分割</title>
      <link>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</link>
      <pubDate>Mon, 17 Feb 2020 14:44:55 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</guid>
      <description>一、滤波 滤波是一种卷积操作，常用于图像的预处理。低通滤波器就是允许低频信号通过，在图像中边缘和噪点都相当于高频部分，所以低通滤波器用于去除噪点、平滑和模糊图像。高通滤波器则反之，用来增强图像边缘，进行锐化处理。
 低通滤波器是模糊 高通滤波器是锐化  常见噪声有椒盐噪声和高斯噪声，椒盐噪声可以理解为斑点，随机出现在图像中的黑点或白点；高斯噪声可以理解为拍摄图片时由于光照等原因造成的噪声。
1.1 均值滤波 均值滤波是一种最简单的滤波处理，它取的是卷积核区域内元素的均值，用cv2.blur()实现，如3×3的卷积核：
$$ kernel_{m} = \frac{1}{9}\left[ \begin{matrix} 1 &amp;amp; 1 &amp;amp; 1 \newline 1 &amp;amp; 1 &amp;amp; 1 \newline 1 &amp;amp; 1 &amp;amp; 1 \end{matrix} \right] $$
img = cv2.imread(&#39;lena.jpg&#39;) blur = cv2.blur(img, (3, 3)) # 均值模糊  1.2 方框滤波 方框滤波跟均值滤波很像，如3×3的滤波核如下：
$$ kernel_{b} = a\left[ \begin{matrix} 1 &amp;amp; 1 &amp;amp; 1 \newline 1 &amp;amp; 1 &amp;amp; 1 \newline 1 &amp;amp; 1 &amp;amp; 1 \end{matrix} \right] $$</description>
    </item>
    
    <item>
      <title>OpenCV-python：基础</title>
      <link>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 09 Feb 2020 15:57:11 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/opencv-python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>18年结束毕业设计之后，对OpenCV接触很少了。那时使用的是C++，借由最近使用python较多，学习OpenCV-python算是一种温故。本文主要参考了OpenCV-Python图像处理教程以及官方文档。
一、图片 需要注意图片的x，y轴排布，三通道以B-G-R排布，灰度图只有一个通道。
1.1 读取 # 加载灰度图 img = cv2.imread(&#39;lena.jpg&#39;, 0)   参数1：图片的文件名  如果图片放在当前文件夹下，直接写文件名就行了，如&amp;rsquo;lena.jpg&amp;rsquo; 否则需要给出绝对路径，如&amp;rsquo;D:\OpenCVSamples\lena.jpg&amp;rsquo;   参数2：读入方式，省略即采用默认值  cv2.IMREAD_COLOR：彩色图，默认值(1) cv2.IMREAD_GRAYSCALE：灰度图(0) cv2.IMREAD_UNCHANGED：包含透明通道的彩色图(-1)    1.2 显示 # 创建窗口 cv2.namedWindow(&#39;lena2&#39;, cv2.WINDOW_NORMAL)   参数1：窗口名称 参数2：窗口模式  cv2.WINDOW_AUTOSIZE表示窗口大小自适应图片 cv2.WINDOW_NORMAL表示窗口大小可调整    # 显示图片 cv2.imshow(&#39;lena&#39;, img)   参数1：窗口名称 参数2：图片实例  # 保持图片显示 cv2.waitKey(0)    参数：暂停时长，ms
为0时，表示无限长。
  传回按键的ascii码, 如ESC:27、s:115
  1.3 保存 # 保存图片 cv2.</description>
    </item>
    
    <item>
      <title>2019-nCoV 疫情数据可视化地图</title>
      <link>https://lil-q.github.io/blog/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9C%B0%E5%9B%BE/</link>
      <pubDate>Sat, 01 Feb 2020 22:41:13 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9C%B0%E5%9B%BE/</guid>
      <description>数据的获取 在学习该博客的数据爬取时发现数据似乎已经不再更新，所以重新在腾讯新闻网站搜索相关数据。
使用time、json和requests获取数据。
import time, json, requests url = &#39;https://view.inews.qq.com/g2/getOnsInfo?name=disease_h5&amp;amp;callback=&amp;amp;_=%d&#39;%int(time.time()*1000) data = json.loads(requests.get(url=url).json()[&#39;data&#39;]) print(data)  可以看到数据如下所示（省略部分内容）：
{&#39;chinaTotal&#39;: {&#39;date&#39;: &#39;02.01&#39;, &#39;confirm&#39;: &#39;11890&#39;, &#39;suspect&#39;: &#39;17988&#39;, &#39;dead&#39;: &#39;259&#39;, &#39;heal&#39;: &#39;269&#39;}, &#39;lastUpdateTime&#39;: &#39;2020-02-01 21:18:01&#39;, &#39;areaTree&#39;: [{&#39;name&#39;: &#39;中国&#39;, &#39;children&#39;: [{&#39;name&#39;: &#39;湖北&#39;, &#39;children&#39;: [...], &#39;total&#39;: {&#39;confirm&#39;: 7153, &#39;suspect&#39;: 0, &#39;dead&#39;: 249, &#39;heal&#39;: 166}, &#39;today&#39;: {&#39;confirm&#39;: 1347, &#39;suspect&#39;: -49, &#39;dead&#39;: 49, &#39;heal&#39;: 15}}, {&#39;name&#39;: &#39;浙江&#39;, &#39;children&#39;: [...], &#39;total&#39;: {&#39;confirm&#39;: 599, &#39;suspect&#39;: 0, &#39;dead&#39;: 0, &#39;heal&#39;: 20}, &#39;today&#39;: {&#39;confirm&#39;: 62, &#39;suspect&#39;: 0, &#39;dead&#39;: 0, &#39;heal&#39;: 7}}, .</description>
    </item>
    
    <item>
      <title>SQL</title>
      <link>https://lil-q.github.io/blog/sql/</link>
      <pubDate>Thu, 16 Jan 2020 13:59:07 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/sql/</guid>
      <description>SQL基础语句快查
一、定义 结构化查询语言（Structured Query Language，SQL）。是一种 ANSI（American National Standards Institute）标准的计算机语言。目的是访问和处理数据库。
二、查询 - SELECT Select 查询某些属性列（specific columns）的语法：
SELECT column（列名）, another_column, … FROM mytable（表名）;  Select 查询所有列：
SELECT * FROM mytable（表名）;  三、条件查询 - WHERE 条件查询语法，WHERE：
SELECT column, another_column, … FROM mytable WHERE condition AND/OR another_condition AND/OR …;  参考下表：
   Operator（关键字） Condition（意思） SQL Example(例子）     =, !=, &amp;lt; &amp;lt;=, &amp;gt;, &amp;gt;= Standard numerical operators 基础的 大于，等于等比较 col_name !</description>
    </item>
    
    <item>
      <title>查并集</title>
      <link>https://lil-q.github.io/blog/%E6%9F%A5%E5%B9%B6%E9%9B%86-union-find-algorithm/</link>
      <pubDate>Thu, 02 Jan 2020 12:54:02 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E6%9F%A5%E5%B9%B6%E9%9B%86-union-find-algorithm/</guid>
      <description>查并集的进化之路
一、定义 并查集是一种树形的数据结构，顾名思义，它用于处理一些不交集的 合并 及 查询 问题。 它支持两种操作：
 查找（Find）：确定某个元素处于哪个子集； 合并（Union）：将两个子集合并成一个集合。  也就是说，不支持集合的分离、删除。
二、Quick-Find算法 以下图为例，连通关系为[(1,2), (0, 1), (0, 3), (4, 7), (5, 6), (5, 7), (7, 8), (8, 9)]。
首先初始化所有节点，认为它们属于一个组，因此不连通的节点必然就属于不同的组：
   element 0 1 2 3 4 5 6 7 8 9     group number / id 0 1 2 3 4 5 6 7 8 9    输入pair(1, 2)，则将所有group number为0和1的element改为一致（都为0或都为1，这里以较小值为例）。
   element 0 1 2 3 4 5 6 7 8 9     group number / id 0 1 1 3 4 5 6 7 8 9    输入pair(0， 1)，这里就需要把element 1和element 2的group number都改为0，：</description>
    </item>
    
    <item>
      <title>图论</title>
      <link>https://lil-q.github.io/blog/%E5%9B%BE-graph/</link>
      <pubDate>Fri, 27 Dec 2019 17:53:49 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E5%9B%BE-graph/</guid>
      <description>生活不就是一张图吗？
一、定义 图（Graph）用于表示物件与物件之间的关系，是图论的基本研究对象。一张图由一些小圆点（称为顶点或结点）和连结这些圆点的直线或曲线（称为边）组成。
一个图 $G$ 是一个二元组，即序偶 $\langle V,E\rangle$ ，或记作 $G= \langle V,E\rangle$ ，其中 $V$ 是有限非空集合，称为 $G$ 的顶点集， $V$ 中的元素称为顶点或结点； $E$ 称为 $G$ 的边的集合， $\forall e_i \in E$ ，都有 $V$ 中的结点与之对应，称 $e_i$ 为 $G$ 的边。
简单来说，就是图 $G$ 就是一个结点的集合 $V$ 和边的集合 $E$ ，其中任意一条边都可以表示为两个结点之间的关系。若 $e_i\in E$ 表示为 $\langle u,v\rangle$ ，则有 $u\in V , v\in V$ 。
1.1 基本概念 无向图：每条边都是无向边的图。
有向图：每条边都是有向边的图。
有权图：每条边具有一定的权重（weight），通常是一个数字
无权图：每条边均没有权重，也可以理解为权为 1
连通图：所有的点都有路径相连
非连通图：存在某两个点没有路径相连
邻接：关联于同一条边的两个点 $u$ 和 $v$ 称为邻接的；关联于同一个点的两条边 $e_1$ 和 $e_2$ 是邻接的（或相邻的）。</description>
    </item>
    
    <item>
      <title>树</title>
      <link>https://lil-q.github.io/blog/%E6%A0%91-tree/</link>
      <pubDate>Wed, 04 Dec 2019 21:53:50 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E6%A0%91-tree/</guid>
      <description>之所以叫树是因为他看起来像一棵倒挂的树
一、定义 树（tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 n（n&amp;gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：
 每个节点都只有有限个子节点或无子节点； 没有父节点的节点称为根节点； 每一个非根节点有且只有一个父节点； 除了根节点外，每个子节点可以分为多个不相交的子树； 树里面没有环路（cycle）。  术语
 节点的度(Degree)：一个节点含有的子树的个数称为该节点的度； 树的度(Degree of tree)：一棵树中，最大的节点度称为树的度； 叶节点(Leaf)：度为零的节点； 分支节点(Branch node)：度不为零的节点； 父节点(Parent)：若一个节点含有子节点，则这个节点称为其子节点的父节点； 子节点(child)：一个节点含有的子树的根节点称为该节点的子节点； 兄弟节点(siblings)：具有相同父节点的节点互称为兄弟节点； 层次(level)：从根开始定义起，根为第 1 层，根的子节点为第 2 层，以此类推； 深度(depth)：对于任意节点 n，n 的深度为从根到n的唯一路径长，根的深度为 0； 高度(height)：对于任意节点 n，n 的高度为从n到一片树叶的最长路径长，所有树叶的高度为 0； 节点的祖先(ancestor)：从根到该节点所经分支上的所有节点； 森林(forest)：由 m（m &amp;gt;= 0）棵互不相交的树的集合称为森林。  分类
本文将介绍二叉树（Binary tree）、二叉搜索树（Binary search tree）和字典树（Trie）。关于AVL树（AVL tree）、红黑树（Red–black tree）和Ｂ树（B-tree），不做深入探讨。
这里区分一下完全二叉树、满二叉树、完美二叉树:
 完全二叉树：最后一层的叶子节点均需在最左边 满二叉树：满足完全二叉树性质，树中除了叶子节点，每个节点都有两个子节点 完美二叉树：满足满二叉树性质，树的叶子节点铺满最后一层  二、二叉树 二叉树（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。通常分支被称作 “左子树” 或 “右子树”。二叉树的分支具有左右次序，不能随意颠倒。
# 建一个单节点 class Node(object): def __init__(self, value): self.</description>
    </item>
    
    <item>
      <title>堆</title>
      <link>https://lil-q.github.io/blog/%E5%A0%86-heap/</link>
      <pubDate>Sun, 17 Nov 2019 15:49:44 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E5%A0%86-heap/</guid>
      <description>经过努力，最值总会冒上来的！
一、定义  在通常情况下，使用列表储存堆，堆树是一颗完全二叉树，二项堆和斐波那契堆不属于二叉树 堆树中某个节点的值总是不大于或不小于其孩子节点的值 堆树中每个节点的子树都是堆树  当父节点的键值总是大于或等于任何一个子节点的键值时为最大堆。 当父节点的键值总是小于或等于任何一个子节点的键值时为最小堆。 本文以最大堆作为例子，最小堆类似。
二、堆的建立 堆的建立并不建立一个新的树，而是对数组进行原地改动，第一个数（index=0）为完全二叉树的 level 0，即根，第二个数和第三个数为 level 1，以此类推。
由于数组是升序数组，我们直接得到了最小堆。但是如果要进行升序排序，算法上需要建立最大堆。也就是说，当原数组是升序时，堆排序算法遇到了最坏情况。本文也以这种情况作为例子。
nums=[1,2,3,4,5]  2.1 堆的维护 上图的根节点是 1，小于子节点，那么这显然违反了最大堆的性质，这时候需要让该元素在最大堆中逐级下降，维护最大堆的性质。处理一次维护的代码如下：
def adjust_heap(idx, max_len,nums): left = 2 * idx + 1 right = 2 * idx + 2 max_loc = idx if left &amp;lt; max_len and nums[max_loc] &amp;lt; nums[left]: max_loc = left if right &amp;lt; max_len and nums[max_loc] &amp;lt; nums[right]: max_loc = right if max_loc != idx: nums[idx], nums[max_loc] = nums[max_loc], nums[idx] adjust_heap(max_loc, max_len,nums)  2.</description>
    </item>
    
    <item>
      <title>排序算法</title>
      <link>https://lil-q.github.io/blog/%E6%8E%92%E5%BA%8F-sort-%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 16 Nov 2019 19:34:55 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E6%8E%92%E5%BA%8F-sort-%E7%AE%97%E6%B3%95/</guid>
      <description>十种排序算法的 python 实现及复杂度分析
分类 评价排序算法的几个指标：
 时间复杂度：包括平均时间复杂度、最坏时间复杂度和最好时间复杂度。一般而言，好的性能是 $O(nlog_2n)$，坏的性能是 $O(n^2)$。对于一个排序理想的性能是 $O(n)$，但平均而言不可能达到。基于比较的排序算法对大多数输入而言至少需要 $O(nlog_2n)$。 空间复杂度：内存使用量 稳定性： 稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录 R 和 S，且在原本的列表中 R 出现在 S 之前，在排序过的列表中 R 也将会是在 S 之前。 依据排序的方法：插入、交换、选择、合并等等。  本文介绍了以下几种排序，推荐可视化网站 visualgo，下文代码都采用数组作为输入。
   排序方法 平均时间复杂度 最坏时间复杂度 最好时间复杂度 空间复杂度 稳定性     冒泡
排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 稳定   选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定   插入排序 $O(n^2)$ $O(n^2)$ $O(n)$ $O(1)$ 稳定   堆排序 $O(nlog_2n)$ $O(nlog_2n)$ $O(nlog_2n)$ $O(1)$ 不稳定   归并排序 $O(nlog_2n)$ $O(nlog_2n)$ $O(nlog_2n)$ $O(n)$ 稳定   快速排序 $O(nlog_2n)$ $O(n^2)$ $O(nlog_2n)$ $O(log_2n)$ 不稳定   希尔排序 $O(n^{1.</description>
    </item>
    
  </channel>
</rss>