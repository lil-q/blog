<!DOCTYPE html>
<html lang="en-us">

<head>
  <title>java：Map | Homeward</title>

  <meta charset="UTF-8">
  <meta name="language" content="en">
  <meta name="description" content="java常见Map">
  <meta name="keywords" content="java , Map , HashMap , concurrentHashMap">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  
  

  <link rel="shortcut icon" type="image/png" href="/favicon.ico" />

  
  
    
 
  
  
  
  
  
  
    
    <link type="text/css" rel="stylesheet" href="/css/post.min.ab05d5e01a9242c9472ee834dca8b5e136420f575e85e4d6d45b56022054489f.css" integrity="sha256-qwXV4BqSQslHLug03Ki14TZCD1deheTW1FtWAiBUSJ8="/>
  
    
    <link type="text/css" rel="stylesheet" href="/css/custom.min.c4ff55c4c110e477d6af24de399f1d98ff8f26c26b502c631e6763d0b525ac4c.css" integrity="sha256-xP9VxMEQ5HfWryTeOZ8dmP&#43;PJsJrUCxjHmdj0LUlrEw="/>
  
  
   
   
    

<script type="application/ld+json">
  
    {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/lil-q.github.io\/"
      },
      "articleSection" : "blog",
      "name" : "java：Map",
      "headline" : "java：Map",
      "description" : "java常见Map",
      "inLanguage" : "en-US",
      "author" : "",
      "creator" : "",
      "publisher": "",
      "accountablePerson" : "",
      "copyrightHolder" : "",
      "copyrightYear" : "2020",
      "datePublished": "2020-04-02 15:37:30 \u002b0000 UTC",
      "dateModified" : "2020-04-02 15:37:30 \u002b0000 UTC",
      "url" : "https:\/\/lil-q.github.io\/blog\/java%E5%9F%BA%E7%A1%80%E4%BA%94\/",
      "wordCount" : "2124",
      "keywords" : ["java", "Map", "HashMap", "concurrentHashMap", "Blog"]
    }
  
  </script>
</head>

<body>
  <div class="burger__container">
  <div class="burger" aria-controls="navigation" aria-label="Menu">
    <div class="burger__meat burger__meat--1"></div>
    <div class="burger__meat burger__meat--2"></div>
    <div class="burger__meat burger__meat--3"></div>
  </div>
</div>
 

  <nav class="nav" id="navigation">
  <ul class="nav__list">
    
    
      <li>
        <a  href="/">About</a>
      </li>
    
      <li>
        <a  class="active"
         href="/blog">技术</a>
      </li>
    
      <li>
        <a  href="/picture">相册</a>
      </li>
    
      <li>
        <a  href="/essay">随笔</a>
      </li>
    
  </ul>
</nav>


  <main>
    
    

    <div class="flex-wrapper">
      <div class="post__container">
        <div class="post">
          <header class="post__header">
            <h1 id="post__title">java：Map</h1>
            <time datetime="2020-04-02 15:37:30 &#43;0000 UTC" class="post__date">Apr 2 2020</time> 
          </header>
          <article class="post__content">
              
<h2 id="一map">一、Map<a class="anchor" href="#一map">#</a></h2>
<p>Map 是一种键-值映射表，当我们调用<code>put(K key, V value)</code>方法时，就把 key 和 value 做了映射并放入 Map。当我们调用<code>V get(K key)</code>时，就可以通过 key 获取到对应的 value。如果 key 不存在，则返回 null。和 List 类似，Map 也是一个接口，最常用的实现类是 HashMap。</p>
<p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/june/Map3.png"  /></p>
<ul>
<li><strong>TreeMap</strong>：基于<strong>红黑树</strong>实现。</li>
<li><strong>HashMap</strong>：基于<strong>哈希表</strong>实现。</li>
<li><strong>HashTable</strong>：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li>
<li><strong>LinkedHashMap</strong>：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</li>
</ul>
<h3 id="11-map-遍历">1.1 Map 遍历<a class="anchor" href="#11-map-遍历">#</a></h3>
<p>要遍历 key 可以使用<code>for each</code>循环遍历 Map 实例的<code>keySet()</code>方法返回的 Set 集合，它包含不重复的 key 的集合：</p>
<pre><code class="language-java">for (String key : map.keySet()) {...}
</code></pre>
<p>同时遍历 key 和 value 可以使用<code>for each</code>循环遍历 Map 对象的<code>entrySet()</code>集合，它包含每一个 key-value 映射：</p>
<pre><code class="language-java">for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {...}
</code></pre>
<h3 id="12-equals--hashcode">1.2 equals() &amp; hashCode()<a class="anchor" href="#12-equals--hashcode">#</a></h3>
<p>正确使用 Map 必须保证：</p>
<ol>
<li>作为 key的对象必须正确覆写<code>equals()</code>方法，相等的两个 key 实例调用<code>equals()</code>必须返回<code>true</code>；</li>
<li>作为 key 的对象还必须正确覆写<code>hashCode()</code>方法，且<code>hashCode()</code>方法要严格遵循以下规范：
<ul>
<li>如果两个对象相等，则两个对象的<code>hashCode()</code>必须相等；</li>
<li>如果两个对象不相等，则两个对象的<code>hashCode()</code>尽量不要相等。</li>
</ul>
</li>
</ol>
<p>自己写<code>hashCode()</code>时R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p>
<pre><code class="language-java">@Override
public int hashCode() {
    int result = 17;
    result = 31 * result + x;
    result = 31 * result + y;
    result = 31 * result + z;
    return result;
}
</code></pre>
<p>和实现<code>equals()</code>方法遇到的问题类似，如果传入值为 null，就会抛<code>NullPointerException</code>。为了解决这个问题，我们在计算<code>hashCode()</code>的时候，经常借助<code>Objects.hash()</code>来计算：</p>
<pre><code class="language-java">int hashCode() {
    return Objects.hash(firstName, lastName, age);
}
</code></pre>
<p>所以，编写<code>equals()</code>和<code>hashCode()</code>遵循的原则是：<code>equals()</code>用到的用于比较的每一个字段，都<strong>必须</strong>在<code>hashCode()</code>中用于计算；<code>equals()</code>中没有使用到的字段，<strong>绝不可</strong>放在<code>hashCode()</code>中计算。</p>
<p><code>Objects.hash()</code>内部实现实则为<code>Arrays.hashCode()</code>方法</p>
<pre><code class="language-java">public static int hash(Object... values) {
    return Arrays.hashCode(values);
}
</code></pre>
<p><code>Arrays.hashCode()</code>源码：</p>
<pre><code class="language-java">public static int hashCode(Object a[]) {
    if (a == null)
        return 0;

    int result = 1;

    for (Object element : a)
        result = 31 * result + (element == null ? 0 : element.hashCode());

    return result;
}
</code></pre>
<p>注意 Objects.hash(Object&hellip;)，它的参数为不定参数，需要为 Object 对象。这会有以下一些影响：</p>
<ol>
<li>对基本类型做 hashCode 需要转换为包装类型，如 long 转换为 Long；</li>
<li>会创建一个 Object 数组。</li>
</ol>
<p>如果<code>hashCode()</code>方法被频繁调用的话，会有一定的性能影响。</p>
<h3 id="13-hashcode">1.3 hashCode()<a class="anchor" href="#13-hashcode">#</a></h3>
<p><code>hashCode()</code>内部使用了数组，在初始化时默认的数组大小只有 16，任何 key 无论<code>hashCode()</code>多大都可以用类似方式处理：</p>
<pre><code class="language-java">int index = key.hashCode() &amp; 0xf;
</code></pre>
<p>当这个 hashMap 添加超过16个 key-value 时，hashMap 会自动扩容，没扩容一次容量就会翻倍。因为内存每次扩容会导致重新分配已有的 key-value，所以频繁扩容对 HashMap 的性能影响很大。如果确定要使用 n 个 key-value 的 HashMap，最好在创建时就指定容量：</p>
<pre><code class="language-java">Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(n);
</code></pre>
<h3 id="14-enummap">1.4 EnumMap<a class="anchor" href="#14-enummap">#</a></h3>
<p>如果作为 key 的对象是 enum 类型，那么，还可以使用 Java 集合库提供的一种 EnumMap，它在内部以一个非常紧凑的数组存储 value，并且根据 enum 类型的 key 直接定位到内部数组的索引，并不需要计算<code>hashCode()</code>，不但效率最高，而且没有额外的空间浪费。</p>
<h3 id="15-treemap">1.5 TreeMap<a class="anchor" href="#15-treemap">#</a></h3>
<p>SortedMap 在遍历时严格按照 Key 的顺序遍历，最常用的实现类是 TreeMap。作为 SortedMap 的 Key 必须实现 Comparable 接口，或者传入 Comparator：</p>
<pre><code class="language-java">Map&lt;Person, Integer&gt; map = new TreeMap&lt;&gt;(new Comparator&lt;Person&gt;() {
    public int compare(Person p1, Person p2) {
        return p1.name.compareTo(p2.name);
    }
});
</code></pre>
<p>注意到 Comparator 接口要求实现一个比较方法，它负责比较传入的两个元素 a 和 b:</p>
<ul>
<li>如果 a &lt; b，则返回负数，通常是 -1；</li>
<li>如果 a == b，则返回 0；</li>
<li>如果 a &gt; b，则返回正数，通常是 1。</li>
</ul>
<p>TreeMap 内部根据比较结果对 Key 进行排序。要严格按照<code>compare()</code>规范实现比较逻辑，否则，TreeMap 将不能正常工作。</p>
<p><a href="https://www.nowcoder.com/practice/46e837a4ea9144f5ad2021658cb54c4d?tpId=98&amp;tqId=32824&amp;tPage=1&amp;rp=1&amp;ru=/ta/2019test&amp;qru=/ta/2019test/question-ranking">nowcoder面试题 找工作</a></p>
<pre><code class="language-java">import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner jin = new Scanner(System.in);
        int N = jin.nextInt();
        int M = jin.nextInt();
        int[][] arr = new int[N][2];
        // 排序
        for (int i = 0; i &lt; N; i++) {
            arr[i][0] = jin.nextInt();
            arr[i][1] = jin.nextInt();
        }
        Arrays.sort(arr, (e1, e2) -&gt; e1[0] - e2[0]);
        // 找出难度对应的最大工资，并保存到TreeMap中
        TreeMap&lt;Integer, Integer&gt; map = new TreeMap();
        for (int i = 0; i &lt; N; i++) {
            if (i &gt; 0 &amp;&amp; arr[i][1] &lt; arr[i - 1][1]) arr[i][1] = arr[i - 1][1];
            map.put(arr[i][0], arr[i][1]);
        }
        // 利用.floorKey()找到最大的小于等于能力值的工作
        for (int i = 0; i &lt; M; i++) {
            Integer index = map.floorKey(jin.nextInt());
            if (index == null) {
                System.out.println(0);
            } else {
                System.out.println(map.get(index));
            }
        }
    }
}
</code></pre>
<h2 id="二hashmap">二、HashMap<a class="anchor" href="#二hashmap">#</a></h2>
<p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/june/Map2.png" alt="hashmap"  /></p>
<pre><code class="language-java">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, Serializable {...}
</code></pre>
<p>默认的容量是 16：</p>
<pre><code class="language-java">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16
</code></pre>
<h3 id="21-储存结构">2.1 储存结构<a class="anchor" href="#21-储存结构">#</a></h3>
<p><strong>（1）table</strong></p>
<p>HashMap 内部包含了一个 Node 类型的数组 table。</p>
<pre><code class="language-java">transient Node&lt;K,V&gt;[] table;
</code></pre>
<p>Node 实现了 Map.Entry 接口，包含了四个字段，存储着键值对 Entry(key, value)，hash 和 next。数组 table 中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用<strong>拉链法</strong>来解决冲突，同一个链表中存放<strong>哈希值和散列桶取模运算结果相同</strong>的 Node。</p>
<pre><code class="language-java">/**N
* Basic hash bin node, used for most entries.  (See below for
* TreeNode subclass, and in LinkedHashMap for its Entry subclass.)
*/
static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
    final int hash;
    final K key;
    V value;
    Node&lt;K,V&gt; next;

    Node(int hash, K key, V value, Node&lt;K,V&gt; next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }

    public final K getKey()        { return key; }
    public final V getValue()      { return value; }
    public final String toString() { return key + &quot;=&quot; + value; }

    public final int hashCode() {
        return Objects.hashCode(key) ^ Objects.hashCode(value);
    }

    public final V setValue(V newValue) {
        V oldValue = value;
        value = newValue;
        return oldValue;
    }

    public final boolean equals(Object o) {
        if (o == this)
            return true;
        if (o instanceof Map.Entry) {
            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;
            if (Objects.equals(key, e.getKey()) &amp;&amp;
                Objects.equals(value, e.getValue()))
                return true;
        }
        return false;
    }
}
</code></pre>
<p><strong>（2）put()</strong></p>
<p>public 修饰的<code>put()</code>方法调用了<code>putVal()</code>方法：</p>
<pre><code class="language-java">public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
</code></pre>
<pre><code class="language-java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    // 当table不存在或长度为0时，新建一个table
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    // 当桶下标对应的node不存在时，新建该Node加入table
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    // 当桶下标对应的Node已经存在时
    else {
        Node&lt;K,V&gt; e; K k;
        // key相同时
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            e = p;
        // Node为TreeNode时
        else if (p instanceof TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        // key不相同，采用尾插法插入Node
        else {
            //遍历链表
            for (int binCount = 0; ; ++binCount) {
                // 到链表末尾但没有相同key，则添加新Node
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    // 链表过长，将链表转为树结构
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                // 找到相同key
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            // onlyIfAbsent 表示是否仅在 oldValue 为 null 的情况下更新键值对的值
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    if (++size &gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
</code></pre>
<p><strong>（3）get()</strong></p>
<pre><code class="language-java">public V get(Object key) {
    Node&lt;K,V&gt; e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
}
</code></pre>
<pre><code class="language-java">final Node&lt;K,V&gt; getNode(int hash, Object key) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (first = tab[(n - 1) &amp; hash]) != null) {
        if (first.hash == hash &amp;&amp; // always check first node
            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
            return first;
        if ((e = first.next) != null) {
            if (first instanceof TreeNode)
                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            do {
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    return null;
}
</code></pre>
<p><strong>（4）遍历</strong></p>
<p>遍历所有的键时，首先要获取键集合 KeySet 对象，然后再通过  KeySet 的迭代器 KeyIterator 进行遍历。KeyIterator 类继承自 HashIterator 类，核心逻辑也封装在 HashIterator 类中。HashIterator 的逻辑并不复杂，在初始化时，HashIterator 先从桶数组中找到包含链表节点引用的桶。然后对这个桶指向的链表进行遍历。遍历完成后，再继续寻找下一个包含链表节点引用的桶，找到继续遍历。找不到，则结束遍历。</p>
<p><strong>（5）桶下标</strong></p>
<p>首先，传入<code>putVal()</code>的<code>hash(key)</code>处理如下，对于 key 为 null 的键值对，返回的 hash 值为 0；其余则是将所得 hashCode 右移 16 位后于原 hashCode 作异或处理：</p>
<pre><code class="language-java">static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}
</code></pre>
<p>在后续的处理中会根据 HashMap 的容量大小取余，得到桶下标：</p>
<pre><code class="language-java">n = table.length;
i = (n - 1) &amp; hash;
</code></pre>
<p>从上面的代码可以发现 hashMap 的 <strong>size 取 2 的幂的好处</strong>，再求桶下标时，只需要进行简单快速的位运算即可求余，且余数中的每一位都得到了保留，减少了哈希碰撞的可能。</p>
<p><strong>（6）拉链法</strong></p>
<p>JDK1.8 开始，HashMap 由链表的头插法改变成了<strong>尾插法</strong>，因此不再会造成死循环，改成尾插法也是为了能够更好的维护 jdk1.8 中 HashMap 的红黑树结构。</p>
<p><strong>（7）黑红树</strong></p>
<p>当链表变长时，查找和添加的速度会变慢，JDK1.8 后加入了链表转换为黑红树的机制，当链表长度超过 TREEIFY_THRESHOLD（默认为8）时，会转化成黑红树。</p>
<pre><code class="language-java">static final int TREEIFY_THRESHOLD = 8;
static final int UNTREEIFY_THRESHOLD = 6;
</code></pre>
<p>在键类没有实现 comparable 接口的情况下，HashMap 会做以下三步处理：</p>
<ol>
<li>比较键与键之间 hash 值的大小，如果 hash 值相同，则</li>
<li>检测键类是否实现了 Comparable 接口，是则调用 <code>compareTo()</code> 方法进行比较，否则</li>
<li>如果仍未比较出大小，就需要进行仲裁了，仲裁方法为 tieBreakOrder。</li>
</ol>
<p><strong>（8）加载因子</strong></p>
<p>初始容量 initialCapacity 是哈希表中初始桶的数量，加载因子 loadFactor 是哈希表在其容量自动扩容之前可以达到多满的一种度量。当哈希表中的条目数超出了<strong>加载因子与当前容量的乘积</strong>时，则要对该哈希表进行扩容、rehash 操作（即重建内部数据结构），扩容后的哈希表将具有<strong>两倍</strong>的原容量。</p>
<p>通常，加载因子需要<strong>在时间和空间成本上寻求一种折衷</strong>，默认为 0.75f。加载因子过高，例如为 1，虽然减少了空间开销，提高了空间利用率，但同时也增加了查询时间成本；加载因子过低，例如 0.5，虽然可以减少查询时间成本，但是空间利用率很低，同时提高了 rehash 操作的次数。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数，所以，一般在使用 HashMap 时建议根据预估值设置初始容量，减少扩容操作。</p>
<h3 id="22-扩容">2.2 扩容<a class="anchor" href="#22-扩容">#</a></h3>
<p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此查找的复杂度为 O(N/M)。</p>
<p>为了让查找的成本降低，应该使 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p>
<pre><code class="language-java">// 键值对的数量
transient int size;
// 装载因子，table 能够使用的比例，threshold = (int)(capacity* loadFactor)。
final float loadFactor;
// size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。
int threshold;
// 默认的装载因子
static final float DEFAULT_LOAD_FACTOR = 0.75f;
</code></pre>
<p>扩容使用 <code>resize()</code> 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，包括链表和黑红树的拆分，因此这一步是很费时的。</p>
<p>在进行扩容时，需要把键值对重新计算桶下标，从而放到对应的桶上。在前面提到，HashMap 使用 hash % capacity 来确定桶下标。capacity 为 2 的 n 次方这一特点能够极大降低重新计算桶下标操作的复杂度。</p>
<p>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：</p>
<pre><code class="language-java">capacity     : 00010000
new capacity : 00100000
</code></pre>
<p>对于一个 Key，它的哈希值 hash 在第 5 位：</p>
<ul>
<li>为 0，那么 hash%00010000 = hash%00100000，桶位置和原来一致；</li>
<li>为 1，hash%00010000 = hash%00100000 + 16，桶位置是原位置 + 16。</li>
</ul>
<h3 id="23-与--hashtable--的比较">2.3 与  Hashtable  的比较<a class="anchor" href="#23-与--hashtable--的比较">#</a></h3>
<ul>
<li>Hashtable 使用 synchronized 来进行同步。</li>
<li>HashMap 可以插入键为 null 的 Entry。</li>
<li>HashMap 的迭代器是 fail-fast 迭代器。</li>
<li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li>
</ul>
<h3 id="24-简易实现">2.4 简易实现<a class="anchor" href="#24-简易实现">#</a></h3>
<pre><code class="language-java">public class MyHashMap&lt;K,V&gt; {

    // 最大容量，即桶数组 table 的大小
    int capacity;

    // 当前 key-value 条目数
    int size = 0;

    // 负载因子，当 size &gt;= table * loadFactor 时，扩容
    final float loadFactor;

    // 桶数组，存放 Entry 链表
    Entry&lt;K,V&gt;[] table;

    // 键值对 Entry，格外保存 hash 和 next
    static class Entry&lt;K,V&gt; {
        final int hash;
        final K key;
        V value;
        Entry&lt;K, V&gt; next;

        Entry(int hash, K key, V value) {
            this.hash = hash;
            this.key = key;
            this.value = value;
        }
    }

    // 求 hash，对 Object 方法 HashCode() 得到的 hashcode 上下 16 位异或
    // 因为后续求桶下标实际上可能不会用到全部 hashcode，将高位异或到低位可以增加离散度
    static int hash(Object key) {
        int h = key.hashCode();
        return h ^ (h &gt;&gt;&gt; 16);
    }

    public MyHashMap() {
        capacity = 16;
        loadFactor = 0.75f;
        table = new Entry[capacity];
    }

    public V get(Object key) {
        return getEntry(hash(key), key);
    }

    private V getEntry(int hash, Object key) {
        int index = hash &amp; (capacity - 1);
        Entry&lt;K,V&gt; curr = table[index];
        while (curr != null) {
            if (curr.key.equals(key)) {
                return curr.value;
            }
            curr = curr.next;
        }
        return null;
    }

    public void put(K key, V value) {
        if (size &gt;= capacity * loadFactor) {
            resize();
        }
        size++;
        putVal(hash(key), key, value);
    }

    private void putVal(int hash, K key, V value) {
        int index = hash &amp; (capacity - 1);
        if (table[index] == null) {
            table[index] = new Entry&lt;&gt;(hash, key, value);
        } else {
            Entry&lt;K, V&gt; curr = table[index], prev = null;
            while (curr != null &amp;&amp; !curr.key.equals(key)) {
                prev = curr;
                curr = curr.next;
            }
            if (curr == null) {
                prev.next = new Entry&lt;&gt;(hash, key, value);
            } else {
                curr.value = value;
            }
        }
    }

    private void resize() {
        capacity &lt;&lt;= 1;
        Entry&lt;K,V&gt;[] oldTable = table;
        table = new Entry[capacity];
        for (Entry entry : oldTable) {
            if (entry == null) continue;
            Entry curr = entry;
            while (curr != null) {
                // 注意到调用的是 putVal，这不会增加 size 的计数
                putVal(entry.hash, (K)entry.key, (V)entry.value);
                curr = curr.next;
            }
        }
    }
}
</code></pre>
<h2 id="三concurrenthashmap">三、ConcurrentHashMap<a class="anchor" href="#三concurrenthashmap">#</a></h2>
<h3 id="31-存储结构">3.1 存储结构<a class="anchor" href="#31-存储结构">#</a></h3>
<p><img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/june/Map1.png" alt="img" style="zoom: 100%;" /></p>
<p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。</p>
<p>Segment 继承自 ReentrantLock。默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p>
<pre><code class="language-java">static final class HashEntry&lt;K,V&gt; {
    final int hash;
    final K key;
    volatile V value;
    volatile HashEntry&lt;K,V&gt; next;
}

static final int DEFAULT_CONCURRENCY_LEVEL = 16;
</code></pre>
<h3 id="32-size-操作">3.2 size 操作<a class="anchor" href="#32-size-操作">#</a></h3>
<p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p>
<p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p>
<p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p>
<p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p>
<p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p>
<h3 id="33-jdk-18-的改动">3.3 JDK 1.8 的改动<a class="anchor" href="#33-jdk-18-的改动">#</a></h3>
<p>JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。</p>
<p>JDK 1.8 使用了 <strong>CAS</strong> 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 <strong>synchronized</strong>。</p>
<p>并且 JDK 1.8 的实现也在链表过长时会转换为<strong>红黑树</strong>。</p>
<h4 id="1-读不加锁">1. 读不加锁</h4>
<p>我们通常使用读写锁来保护对一堆数据的读写操作。读时加读锁，写时加写锁。 ConcurrentHashMap 对数据的写操作是不需要分 2 次写的（没有中间状态），读操作也是不需要 2 次读取的。假如一个写操作需要分多次写，必然会有中间状态，如果读不加锁，那么可能就会读到中间状态，那就不对了。</p>
<p>虽然 ConcurrentHashMap 的读不需要锁，但是需要保证能读到最新数据，所以必须加 <strong>volatile</strong>。即数组的引用需要加 volatile，同时一个 Node 节点中的 <strong>val</strong> 和 <strong>next</strong> 属性也必须要加 volatile。</p>
<h4 id="2-迁移中的并发处理">2. 迁移中的并发处理</h4>
<p>（1）在某个桶的<strong>迁移过程</strong>中，别的线程要对该桶进行 put 操作</p>
<p>一旦某个桶在迁移过程中了，必然要获取该桶的锁，所以其他线程的put操作要被阻塞，一旦迁移完毕，该桶中第一个元素就会被设置成 ForwardingNode 节点，所以其他线程 put 时需要重新判断下桶中第一个元素是否被更改了，如果被改了重新获取重新执行。</p>
<p>（2）某个桶已经<strong>迁移完成（其他桶还未完成）</strong>，别的线程要对该桶进行 put 操作</p>
<p>该线程会首先检查是否还有未分配的迁移任务，如果有则先去执行迁移任务，如果没有即全部任务已经分发出去了，那么此时该线程可以直接对新的桶进行插入操作（映射到的新桶必然已经完成了迁移，所以可以放心执行操作）。</p>
<h2 id="四linkedhashmap">四、LinkedHashMap<a class="anchor" href="#四linkedhashmap">#</a></h2>
<pre><code class="language-java">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt;
    implements Map&lt;K,V&gt; {...}
</code></pre>
<p>继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。</p>
<pre><code class="language-java">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {
    Entry&lt;K,V&gt; before, after;
    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {
        super(hash, key, value, next);
    }
}
</code></pre>
<p>Entry 类继承自 HashMap.Node，可见内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。</p>
<pre><code class="language-java">// The head (eldest) of the doubly linked list.
transient LinkedHashMap.Entry&lt;K,V&gt; head;

// The tail (youngest) of the doubly linked list.
transient LinkedHashMap.Entry&lt;K,V&gt; tail;
</code></pre>
<p>accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。显式设置为 true，代表以访问顺序进行迭代。</p>
<pre><code class="language-java">final boolean accessOrder;
</code></pre>
<p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 <code>put()</code>、<code>get()</code> 等方法中调用。LinkedHashMap 并没有覆写<code>put()</code>，而是覆写了<code>afterNodeAccess(Node&lt;K,V&gt; p)</code>。</p>
<pre><code class="language-java">void afterNodeAccess(Node&lt;K,V&gt; p) { }
void afterNodeInsertion(boolean evict) { }
</code></pre>
<h3 id="41-afternodeaccess">4.1 afterNodeAccess()<a class="anchor" href="#41-afternodeaccess">#</a></h3>
<p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p>
<pre><code class="language-java">void afterNodeAccess(Node&lt;K,V&gt; e) { // move node to last
    LinkedHashMap.Entry&lt;K,V&gt; last;
    if (accessOrder &amp;&amp; (last = tail) != e) {
        LinkedHashMap.Entry&lt;K,V&gt; p =
            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
        p.after = null;
        if (b == null)
            head = a;
        else
            b.after = a;
        if (a != null)
            a.before = b;
        else
            last = b;
        if (last == null)
            head = p;
        else {
            p.before = last;
            last.after = p;
        }
        tail = p;
        ++modCount;
    }
}
</code></pre>
<h3 id="42-afternodeinsertion">4.2 afterNodeInsertion()<a class="anchor" href="#42-afternodeinsertion">#</a></h3>
<p>在 <code>put()</code> 等操作之后执行，当 <code>removeEldestEntry()</code> 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。evict 只有在构建 Map 的时候才为 false，在这里为 true。</p>
<pre><code class="language-java">void afterNodeInsertion(boolean evict) { // possibly remove eldest
    LinkedHashMap.Entry&lt;K,V&gt; first;
    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) {
        K key = first.key;
        removeNode(hash(key), key, null, false, true);
    }
}Copy to clipboardErrorCopied
</code></pre>
<p><code>removeEldestEntry()</code> 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p>
<pre><code class="language-java">protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) {
    return false;
}
</code></pre>
<h3 id="43-实现lru缓存">4.3 实现LRU缓存<a class="anchor" href="#43-实现lru缓存">#</a></h3>
<p>以下是使用 LinkedHashMap 实现的一个 LRU 缓存：</p>
<pre><code class="language-java">class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; { // 继承自LinkedHashMap
    // 最大缓存空间MAX_ENTRIES，默认值为3
    private static final int MAX_ENTRIES = 3;
    
    // 覆写
    protected boolean removeEldestEntry(Map.Entry eldest) {
        return size() &gt; MAX_ENTRIES;
    }
    
    // 初始化，将 accessOrder 设置为 true
    LRUCache() {
        super(MAX_ENTRIES, 0.75f, true);
    }
    
    public int get(int key) {
        return super.getOrDefault(key, -1);
    }
    
    public void put(int key, int value) {
        super.put(key, value);
    }
}
</code></pre>
<h2 id="五weakhashmap">五、WeakHashMap<a class="anchor" href="#五weakhashmap">#</a></h2>
<p>WeakHashMap 的 Entry 继承自 <strong>WeakReference</strong>，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。</p>
<p>WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。</p>
<pre><code class="language-java">public class WeakHashMap&lt;K,V&gt;
    extends AbstractMap&lt;K,V&gt;
    implements Map&lt;K,V&gt; {...}
</code></pre>
<h3 id="51-弱引用">5.1 弱引用<a class="anchor" href="#51-弱引用">#</a></h3>
<p>当一个对象仅仅被 WeakReference 引用时，在下个垃圾收集周期时候该对象就会被回收，可以通过下面代码创建一个 WeakReference：</p>
<pre><code class="language-java">Integer referent = 1;  
WeakReference&lt;Integer&gt; wr = new WeakReference&lt;Integer&gt;(referent);
referent = null;
</code></pre>
<p>当把 referent 赋值为 null 的时候，wr 会在下一个垃圾收集周期中被回收，因为已经没有强引用指向它。</p>
<h3 id="52-concurrentcache">5.2 ConcurrentCache<a class="anchor" href="#52-concurrentcache">#</a></h3>
<p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。</p>
<p>ConcurrentCache 采取的是分代缓存：</p>
<ul>
<li>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）；</li>
<li>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。</li>
<li>当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。</li>
<li>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。</li>
</ul>
<h2 id="六补充">六、补充<a class="anchor" href="#六补充">#</a></h2>
<p>由于 Java 的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：</p>
<ul>
<li>Hashtable：一种线程安全的 Map 实现；</li>
<li>Vector：一种线程安全的 List 实现；</li>
<li>Stack：基于 Vector 实现的 LIFO 的栈。</li>
</ul>
<p>还有一小部分接口是遗留接口，也不应该继续使用：</p>
<ul>
<li>Enumeration：已被 Iterator 取代。</li>
</ul>
<p>Java的集合类定义在 java.util 包中，支持泛型。Java集合使用统一的 Iterator 遍历，尽量不要使用遗留接口。</p>
<h1 id="参考">参考</h1>
<ol>
<li>[CyC CS-Notes](<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java">https://cyc2018.github.io/CS-Notes/#/notes/Java</a> 容器)</li>
<li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265118019954528">廖雪峰java教程</a></li>
<li><a href="https://my.oschina.net/pingpangkuangmo/blog/817973#h2_17">jdk1.8的HashMap和ConcurrentHashMap</a></li>
<li><a href="https://juejin.im/entry/5a085809f265da430c114c8b">Java中的WeakHashMap</a></li>
<li><a href="https://stackoverflow.com/questions/7136620/weak-references-how-useful-are-they">Weak references - how useful are they?</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/86072774">AQS</a></li>
</ol>


              
          </article>
          

<ul class="tags__list">
    
    <li class="tag__item">
        <a class="tag__link" href="https://lil-q.github.io/tags/java/">java</a>
    </li>
    <li class="tag__item">
        <a class="tag__link" href="https://lil-q.github.io/tags/source_code/">source_code</a>
    </li></ul>

 <div class="pagination">
  
    <a class="pagination__item" href="https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E5%9B%9B/">
        <span class="pagination__label">Previous Post</span>
        <span class="pagination__title">java：Collection</span>
    </a>
  

  
    <a class="pagination__item" href="https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E5%85%AD/">
      <span class="pagination__label">Next Post</span>
      <span class="pagination__title" >java：I/O</a>
    </a>
  
</div>

          
          <footer class="post__footer">
            


<div class="social-icons">
  
     
    
  
     
    
      <a class="social-icons__link" title="GitHub"
         href="https://github.com/lil-q"
         target="_blank" rel="noopener">
        <div class="social-icons__icon" style="background-image: url('https://lil-q.github.io/svg/github.svg')"></div>
      </a>
    
  
     
    
      <a class="social-icons__link" title="Email"
         href="mailto:qitiantianc137@outlook.com"
         target="_blank" rel="noopener">
        <div class="social-icons__icon" style="background-image: url('https://lil-q.github.io/svg/email.svg')"></div>
      </a>
    
     
</div>

            <p>2020 © lil-q</p>
          </footer>
          </div>
      </div>
      
      <div class="toc-container">
          
        <nav id="TableOfContents">
  <ul>
    <li><a href="#一map">一、Map</a>
      <ul>
        <li><a href="#11-map-遍历">1.1 Map 遍历</a></li>
        <li><a href="#12-equals--hashcode">1.2 equals() &amp; hashCode()</a></li>
        <li><a href="#13-hashcode">1.3 hashCode()</a></li>
        <li><a href="#14-enummap">1.4 EnumMap</a></li>
        <li><a href="#15-treemap">1.5 TreeMap</a></li>
      </ul>
    </li>
    <li><a href="#二hashmap">二、HashMap</a>
      <ul>
        <li><a href="#21-储存结构">2.1 储存结构</a></li>
        <li><a href="#22-扩容">2.2 扩容</a></li>
        <li><a href="#23-与--hashtable--的比较">2.3 与  Hashtable  的比较</a></li>
        <li><a href="#24-简易实现">2.4 简易实现</a></li>
      </ul>
    </li>
    <li><a href="#三concurrenthashmap">三、ConcurrentHashMap</a>
      <ul>
        <li><a href="#31-存储结构">3.1 存储结构</a></li>
        <li><a href="#32-size-操作">3.2 size 操作</a></li>
        <li><a href="#33-jdk-18-的改动">3.3 JDK 1.8 的改动</a></li>
      </ul>
    </li>
    <li><a href="#四linkedhashmap">四、LinkedHashMap</a>
      <ul>
        <li><a href="#41-afternodeaccess">4.1 afterNodeAccess()</a></li>
        <li><a href="#42-afternodeinsertion">4.2 afterNodeInsertion()</a></li>
        <li><a href="#43-实现lru缓存">4.3 实现LRU缓存</a></li>
      </ul>
    </li>
    <li><a href="#五weakhashmap">五、WeakHashMap</a>
      <ul>
        <li><a href="#51-弱引用">5.1 弱引用</a></li>
        <li><a href="#52-concurrentcache">5.2 ConcurrentCache</a></li>
      </ul>
    </li>
    <li><a href="#六补充">六、补充</a></li>
  </ul>
</nav>
      </div>
      
    </div>
    

  </main>

   

  
  <script src="/js/index.min.49e4d8a384357d9b445b87371863419937ede9fa77737522ffb633073aebfa44.js" integrity="sha256-SeTYo4Q1fZtEW4c3GGNBmTft6fp3c3Ui/7YzBzrr&#43;kQ=" crossorigin="anonymous"></script>
  
  
  <script src="https://unpkg.com/prismjs@1.20.0/components/prism-core.min.js"></script>

  
  <script src="https://unpkg.com/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js"
    data-autoloader-path="https://unpkg.com/prismjs@1.20.0/components/"></script>

  
    <script src="/js/table-of-contents.js"></script>
  


</body>

</html>
