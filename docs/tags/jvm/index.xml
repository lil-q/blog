<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>jvm on Homeward</title>
    <link>https://lil-q.github.io/tags/jvm/</link>
    <description>Recent content in jvm on Homeward</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>{year} © lil-q</copyright>
    <lastBuildDate>Tue, 07 Jul 2020 11:17:47 +0000</lastBuildDate>
    
	<atom:link href="https://lil-q.github.io/tags/jvm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>java-虚拟机</title>
      <link>https://lil-q.github.io/blog/java-%E8%99%9A%E6%8B%9F%E6%9C%BA/</link>
      <pubDate>Tue, 07 Jul 2020 11:17:47 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java-%E8%99%9A%E6%8B%9F%E6%9C%BA/</guid>
      <description>一、内存区域 1.1 程序计数器 程序计数器是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都依赖这个计数器。记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。
1.2 Java 虚拟机栈 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
该区域可能抛出以下异常：
 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常； 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。  1.3 本地方法栈 本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。
本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。
1.4 堆 所有对象都在这里分配内存，是垃圾收集的主要区域（&amp;ldquo;GC 堆&amp;rdquo;）。
现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：
 新生代（Young Generation） 老年代（Old Generation）  堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。
栈和堆的区别如下：
 功能：栈的功能是运行，堆的功能是储存； 共享性：栈是线程隔离的，堆是线程共享的； 异常错误 ：栈可能出 StackOverflowError 异常和 OutOfMemoryError 异常，堆出后者； 空间：栈的空间连续，堆的空间不连续，栈的空间远小于堆。  1.5 方法区 用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。
对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。
HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</description>
    </item>
    
    <item>
      <title>java-并发</title>
      <link>https://lil-q.github.io/blog/java-%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Tue, 28 Apr 2020 19:37:01 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java-%E5%B9%B6%E5%8F%91/</guid>
      <description>计算机的运算速度与它的存储和通信子系统的速度差距太大，大量的时间都花费在磁盘 I/O、网络通信或者数据库访问上。高效并发能能更好的利用计算机的性能。
一、硬件的效率和一致性 由于计算机的存储设备与处理器的运算速度有着几个数量级的差距，所以现代计算机系统都不得不加入一层或多层读写速度尽可能接近处理器运算速度的高速缓存（ Cache）来作为内存与处理器之间的缓冲：将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。
基于高速缓存的存储交互很好地解决了处理器与内存速度之间的矛盾，但是也为计算机系统带来更高的复杂度，它引入了一个新的问题：缓存一致性（ Cache Coherence）。在多路处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（ Main Memory），这种系统称为共享内存多核系统（ Shared Memory Multiprocessors System），如下图所示。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。
为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作。
除了増加高速缓存之外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，让指令的执行能够尽可能的并行起来。处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java 虚拟机的即时编译器中也有指令重排序（ Instruction Reorder）优化。
即使是单线程，指令重排仍然能加速执行，因为一个非原子操作指令也会涉及到很多步骤，每个步骤可能会用到不同的寄存器，CPU使用了流水线技术，也就是说，CPU有多个功能单元（如获取、解码、运算和结果），一条指令也分为多个单元，那么第一条指令执行还没完毕，就可以执行第二条指令，前提是这两条指令功能单元相同或类似，所以一般可以通过指令重排使得具有相似功能单元的指令接连执行来减少流水线中断的情况。
二、Java 内存模型 Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。
 此处的变量（Variables）与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。
 Java内存模型规定了所有的变量都存储在主内存（ Main Memory，与硬件的主内存同名，但物理上它仅是虚拟机内存的一部分）。每条线程还有自己的工作内存（ Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成（如果局部变量是一个 reference 类型，它引用的对象在Java堆中可被各个线程共享，但是 reference 本身在 Java 栈的局部变量表中是线程私有的）。
2.1 内存间交互操作 Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于 double 和 long 类型的变量来说， load、 store、read 和 write 操作在某些平台r上允许有例外）。
 lock：作用于主内存的变量，标识为一条线程独占。 unlock：作用于主内存的变量，释放处于锁定状态的变量。 read：作用于主内存的变量，传输到工作内存中。 load：作用于工作内存的变量，在 read 之后执行，把值放入工作内存的变量副本中。 use：作用于工作内存的变量，传递给执行引擎。 assign：作用于工作内存的变量，把一个从执行引擎接收到的值赋给工作内存的变量。 store：作用于工作内存的变量，把一个变量的值传送到主内存中。 write：作用于主内存的变量，在 store 之后执行，把值放入主内存的变量中。  2.</description>
    </item>
    
  </channel>
</rss>