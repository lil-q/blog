<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on Homeward</title>
    <link>https://lil-q.github.io/tags/java/</link>
    <description>Recent content in java on Homeward</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>{year} © lil-q</copyright>
    <lastBuildDate>Tue, 07 Jul 2020 11:17:47 +0000</lastBuildDate>
    
	<atom:link href="https://lil-q.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>java-虚拟机</title>
      <link>https://lil-q.github.io/blog/java-%E8%99%9A%E6%8B%9F%E6%9C%BA/</link>
      <pubDate>Tue, 07 Jul 2020 11:17:47 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java-%E8%99%9A%E6%8B%9F%E6%9C%BA/</guid>
      <description>一、内存区域 1.1 程序计数器 程序计数器是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都依赖这个计数器。记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。
1.2 Java 虚拟机栈 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
该区域可能抛出以下异常：
 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常； 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。  1.3 本地方法栈 本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。
本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。
1.4 堆 所有对象都在这里分配内存，是垃圾收集的主要区域（&amp;ldquo;GC 堆&amp;rdquo;）。
现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：
 新生代（Young Generation） 老年代（Old Generation）  堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。
栈和堆的区别如下：
 功能：栈的功能是运行，堆的功能是储存； 共享性：栈是线程隔离的，堆是线程共享的； 异常错误 ：栈可能出 StackOverflowError 异常和 OutOfMemoryError 异常，堆出后者； 空间：栈的空间连续，堆的空间不连续，栈的空间远小于堆。  1.5 方法区 用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。
对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。
HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</description>
    </item>
    
    <item>
      <title>java-并发</title>
      <link>https://lil-q.github.io/blog/java-%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Tue, 28 Apr 2020 19:37:01 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java-%E5%B9%B6%E5%8F%91/</guid>
      <description>计算机的运算速度与它的存储和通信子系统的速度差距太大，大量的时间都花费在磁盘 I/O、网络通信或者数据库访问上。高效并发能能更好的利用计算机的性能。
一、硬件的效率和一致性 由于计算机的存储设备与处理器的运算速度有着几个数量级的差距，所以现代计算机系统都不得不加入一层或多层读写速度尽可能接近处理器运算速度的**高速缓存（ Cache）**来作为内存与处理器之间的缓冲：将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。
基于高速缓存的存储交互很好地解决了处理器与内存速度之间的矛盾，但是也为计算机系统带来更高的复杂度，它引入了一个新的问题：缓存一致性（ Cache Coherence）。在多路处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（ Main Memory），这种系统称为共享内存多核系统（ Shared Memory Multiprocessors System），如下图所示。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。
为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作。
除了増加高速缓存之外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，让指令的执行能够尽可能的并行起来。处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java 虚拟机的即时编译器中也有指令重排序（ Instruction Reorder）优化。
二、Java 内存模型 Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。
 此处的变量（Variables）与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。
 Java内存模型规定了所有的变量都存储在主内存（ Main Memory，与硬件的主内存同名，但物理上它仅是虚拟机内存的一部分）。每条线程还有自己的工作内存（ Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成（如果局部变量是一个 reference 类型，它引用的对象在Java堆中可被各个线程共享，但是 reference 本身在 Java 栈的局部变量表中是线程私有的）。
2.1 内存间交互操作 Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于 double 和 long 类型的变量来说， load、 store、read 和 write 操作在某些平台r上允许有例外）。
 lock：作用于主内存的变量，标识为一条线程独占。 unlock：作用于主内存的变量，释放处于锁定状态的变量。 read：作用于主内存的变量，传输到工作内存中。 load：作用于工作内存的变量，在 read 之后执行，把值放入工作内存的变量副本中。 use：作用于工作内存的变量，传递给执行引擎。 assign：作用于工作内存的变量，把一个从执行引擎接收到的值赋给工作内存的变量。 store：作用于工作内存的变量，把一个变量的值传送到主内存中。 write：作用于主内存的变量，在 store 之后执行，把值放入主内存的变量中。  2.2 volatile 关键字 volatile 可以说是 Java 虚拟机提供的最轻量级的同步机制，它将具备两项特性：</description>
    </item>
    
    <item>
      <title>java-I/O</title>
      <link>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E5%85%AD/</link>
      <pubDate>Sat, 04 Apr 2020 14:13:57 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E5%85%AD/</guid>
      <description>一、IO 1.1 File  创建File f = new File(&amp;quot;C:\\Windiws\\...&amp;quot;)对象本身不涉及IO操作，并不会导致任何磁盘操作； 可以获取路径／绝对路径／规范路径：getPath()/getAbsolutePath()/getCanonicalPath()； 可以获取目录的文件和子目录：list()/listFiles()； boolean mkdir()：创建当前File对象表示的目录； boolean mkdirs()：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来； boolean delete()：删除当前File对象表示的目录，当前目录必须为空才能删除成功。  Java I/O 使用了装饰者模式来实现。以 InputStream 为例，
 InputStream 是抽象组件； FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作； FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。  实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。
1.2 输入 InputStream就是Java标准库提供的最基本的输入流。它位于java.io这个包里。java.io包提供了所有同步IO的功能。
InputStream并不是一个接口，而是一个抽象类，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是int read()：
public abstract int read() throws IOException;  这个方法会读取输入流的下一个字节，并返回字节表示的int值（0~255）。如果已读到末尾，返回-1表示不能继续读取了。
FileInputStream是InputStream的一个子类，能从文件流中读取数据。使用try(resource)可以保证InputStream正确关闭（因为InputStream和OutputStream都实现了java.lang.AutoCloseable接口）。
public void readFile() throws IOException { try (InputStream input = new FileInputStream(&amp;quot;src/readme.txt&amp;quot;)) { int n; while ((n = input.</description>
    </item>
    
    <item>
      <title>java-Map</title>
      <link>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E4%BA%94/</link>
      <pubDate>Thu, 02 Apr 2020 15:37:30 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E4%BA%94/</guid>
      <description>一、Map Map是一种键-值映射表，当我们调用put(K key, V value)方法时，就把key和value做了映射并放入Map。当我们调用V get(K key)时，就可以通过key获取到对应的value。如果key不存在，则返回null。和List类似，Map也是一个接口，最常用的实现类是HashMap。
 TreeMap：基于红黑树实现。 HashMap：基于哈希表实现。 HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。  1.1 Map遍历 要遍历key可以使用for each循环遍历Map实例的keySet()方法返回的Set集合，它包含不重复的key的集合：
for (String key : map.keySet()) {...}  同时遍历key和value可以使用for each循环遍历Map对象的entrySet()集合，它包含每一个key-value映射：
for (Map.Entry&amp;lt;String, Integer&amp;gt; entry : map.entrySet()) {...}  1.2 equals() &amp;amp; hashCode() 正确使用Map必须保证：
 作为key的对象必须正确覆写equals()方法，相等的两个key实例调用equals()必须返回true； 作为key的对象还必须正确覆写hashCode()方法，且hashCode()方法要严格遵循以下规范：  如果两个对象相等，则两个对象的hashCode()必须相等； 如果两个对象不相等，则两个对象的hashCode()尽量不要相等。    自己写hashCode()时R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：31*x == (x&amp;lt;&amp;lt;5)-x，编译器会自动进行这个优化。
@Override public int hashCode() { int result = 17; result = 31 * result + x; result = 31 * result + y; result = 31 * result + z; return result; }  和实现equals()方法遇到的问题类似，如果firstName或lastName为null，上述代码工作起来就会抛NullPointerException。为了解决这个问题，我们在计算hashCode()的时候，经常借助Objects.</description>
    </item>
    
    <item>
      <title>java-Collection</title>
      <link>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E5%9B%9B/</link>
      <pubDate>Mon, 30 Mar 2020 18:34:55 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E5%9B%9B/</guid>
      <description>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。
 源码基于java 13。
 一、Collection 二、List List接口，可以看到几个主要的接口方法：
 在末尾添加一个元素：void add(E e) 在指定索引添加一个元素：void add(int index, E e) 删除指定索引的元素：int remove(int index) 删除某个元素：int remove(Object e) 获取指定索引的元素：E get(int index) 获取链表大小（包含元素的个数）：int size()  List接口允许我们添加重复的元素，即List内部的元素可以重复，List还允许添加null。调用List.of()，它返回的是一个只读List：
List&amp;lt;Integer&amp;gt; list = List.of(1, 2, 5);  但是List.of()方法不接受null值，如果传入null，会抛出NullPointerException异常。
2.1 List遍历 List的遍历采用了迭代器的设计模式：
Iterable接口声明如下：
public interface Iterable&amp;lt;T&amp;gt; { Iterator&amp;lt;T&amp;gt; iterator(); }  Iterator接口声明如下：
public interface Iterator&amp;lt;E&amp;gt; { // 判断是否还有下一个对象，如果有，则返回true，否则false boolean hasNext(); // 返回集合的下个值，此方法只能在hasNext方法返回true时调用 E next(); // 删除集合的当前值，此方法也只能在hasNext方法返回true时调用 void remove(); }  ListIterator接口声明如下：</description>
    </item>
    
    <item>
      <title>java-反射和泛型</title>
      <link>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E4%B8%89/</link>
      <pubDate>Fri, 27 Mar 2020 22:45:02 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E4%B8%89/</guid>
      <description>一、反射 由于 JVM 为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息。这种通过Class实例获取class信息的方法称为反射（Reflection）。
Java 反射主要提供以下功能：
 在运行时判断任意一个对象所属的类； 在运行时构造任意一个类的对象； 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）； 在运行时调用任意一个对象的方法。  重点：是运行时而不是编译时。
1.1 Class类 获取一个class的Class实例有三个方法：
方法一：直接通过一个class的静态变量class获取：
Class&amp;lt;?&amp;gt; cls = String.class;  方法二：如果我们有一个实例变量，可以通过该实例变量提供的getClass()方法获取：
String s = &amp;quot;Hello&amp;quot;; Class&amp;lt;?&amp;gt; cls = s.getClass();  方法三：如果知道一个class的完整类名，可以通过静态方法Class.forName()获取：
Class&amp;lt;?&amp;gt; cls = Class.forName(&amp;quot;java.lang.String&amp;quot;);  Class.forName()加载类时默认会初始化，而ClassLoader.loadClass()默认不会初始化，只完成了类加载中的第一步加载。
注意Class实例==比较和instanceof的差别：
Integer n = new Integer(123); boolean b1 = n instanceof Integer; // true，因为n是Integer类型 boolean b2 = n instanceof Number; // true，因为n是Number类型的子类 boolean b3 = n.getClass() == Integer.class; // true，因为n.getClass()返回Integer.class boolean b4 = n.</description>
    </item>
    
    <item>
      <title>java-面向对象和异常处理</title>
      <link>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E4%BA%8C/</link>
      <pubDate>Mon, 23 Mar 2020 14:08:20 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80%E4%BA%8C/</guid>
      <description>一、面向对象 Java是一种面向对象的编程语言。面向对象编程，英文是Object-Oriented Programming，简称OOP。
1.1 权限修饰符     本类 同一个包下（子类和无关类） 不同包下（子类） 不同包下（无关类）     private Y      default Y Y     protected Y Y Y    public Y Y Y Y    一个.java文件只能包含一个public类，但可以包含多个非public类。如果有public类，文件名必须和public类的名字相同。
1.2 继承 如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法。
子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。
 **向上转型（upcasting）：**一个子类类型安全地变为父类类型的赋值。向上转型只能够调用子类重写的方法。 **向下转型（downcasting）：**一个父类类型强制转型为子类类型。找回向上转型时丢失的子类扩展方法。  instanceof判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为null，那么对任何instanceof的判断都为false。
利用instanceof，在向下转型前可以先判断：
Person p = new Student(); if (p instanceof Student) { // 只有判断成功才会向下转型: Student s = (Student) p; // 一定会成功 }  从Java 14开始，判断instanceof后，可以直接转型为指定变量，避免再次强制转型。</description>
    </item>
    
    <item>
      <title>java-基础</title>
      <link>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Fri, 20 Mar 2020 19:33:14 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/java%E5%9F%BA%E7%A1%80/</guid>
      <description>JVM–java virtual machine JVM 是整个 java 实现跨平台的最核心的部分，所有的 java 程序会首先被编译为 .class 的类文件，这种类文件可以在虚拟机上执行，也就是说 class 并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。 JRE – java runtime environment JRE 是指 java 运行环境。在 JDK 的安装目录里你可以找到 jre 目录，里面有两个文件夹 bin 和 lib ，在这里可以认为 bin 里的就是 jvm，lib 中则是 jvm 工作所需要的类库，而 bin 和 lib 和起来就称为 JRE。 JDK – java development kit JDK 是 java 开发工具包，是支持 java 程序开发的最小环境。JDK 对比 JRE 多了 java language 和工具 API。  一、数据类型 1.1 基本类型  byte/8 [-128 ~ 127] char/16 short/16 [-32768 ~ 32767] int/32 [-2147483648 ~ 2147483647] float/32 long/64 [-9223372036854775808 ~ 9223372036854775807] double/64 boolean/~  Java语言对布尔类型的存储并没有做规定，因为理论上存储布尔类型只需要1 bit，但是通常JVM内部会把boolean表示为4字节整数，为了节省内存而表示为更小的类型可能会在之后处理时带来不必要的麻烦。</description>
    </item>
    
  </channel>
</rss>