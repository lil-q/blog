<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>basis on Homeward</title>
    <link>https://lil-q.github.io/tags/basis/</link>
    <description>Recent content in basis on Homeward</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>{year} © lil-q</copyright>
    <lastBuildDate>Mon, 07 Sep 2020 18:54:03 +0800</lastBuildDate>
    
	<atom:link href="https://lil-q.github.io/tags/basis/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>面向对象</title>
      <link>https://lil-q.github.io/blog/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Mon, 07 Sep 2020 18:54:03 +0800</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <description>面向对象程序设计（Object-Oriented Programming，OOP）是一种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的资料。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。
一、特性 1.1 封装 利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。
优点：
 减少耦合：可以独立地开发、测试、优化、使用、理解和修改； 减轻维护的负担：可以更容易被理解，并且在调试的时候可以不影响其他模块； 有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能； 提高软件的可重用性； 降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的。  1.2 继承 继承是指在某种情况下，一个类会有子类。子类比原本的类（称为父类）要更加具体化。java 只允许单继承，一个子类只能继承自一个父类，使用extends关键字。也就是说对于一个类，只能认为它属于另一个大类，如果它需要实现其他功能时，则还要实现功能接口（interface），使用implements关键字。
1.3 多态 C++ 中的虚函数就是为了多态。Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是 Java 的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。
方法的重写（Override）和重载（Overload）是 java 多态性的不同表现。重写解决的是子类与父类针对同一方法需要采取不同实现方式的问题，通过 JVM 在类加载时（解析阶段）的动态绑定机制实现。重载是面向使用者的，针对不同的调用方式返回不同的结果。
二、设计原则 错误的设计类会带来很多问题，比如下面的悖论（为了方便理解，下文中长方形指代长宽不等的矩形）。
2.1 正方形不是矩形？ 首先写出矩形类，定义长和宽，并写出长宽的 setter 方法和一个获取面积的方法：
public class Rectangle { int length; int width; public void setLength(int length) { this.length = length; } public void setWidth(int width) { this.width = width; } public int getArea() { return length * width; } }  写出子类正方形，由于正方形的长宽是相同的，重写两个 setter 方法保证长宽一致：</description>
    </item>
    
    <item>
      <title>操作系统</title>
      <link>https://lil-q.github.io/blog/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Sun, 10 May 2020 00:08:33 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
      <description>操作系统是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。
一、概述 1.1 基础特性 批处理系统有着高资源利用率和系统吞吐量；分时系统能获得及时响应；实时系统具有实时特征。除此之外，操作系统还具有并发、共享、虚拟和异步四个基本特性。
1. 并发 并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。
并行是物理意义上的，需要硬件支持，如多流水线、多核处理器或者分布式计算系统，而并发是逻辑意义上的。
操作系统通过引入进程和线程，使得程序能够并发运行。
2. 共享 共享又称资源复用，是指系统中的资源可以被多个并发进程共同使用。
有两种共享方式：互斥共享和同时共享。
互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。
3. 虚拟 虚拟技术把一个物理实体转换为多个逻辑实体。
主要有两种虚拟技术：时分复用技术和空分复用技术。
多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。
虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。
4. 异步 异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。
1.2 主要功能 1. 进程管理 处理机的分配和运行都是以进程为基本单位。
 进程控制：创建进程和终止已结束进程； 进程同步：进程互斥方式（如加锁）和进程同步方式（如信号量机制）； 进程通信：直接通信方式（如源进程利用发送命令直接把消息挂到目标进程的消息队列上）； 调度：作业调度和进程调度； 死锁处理。  2. 内存管理 为多道程序的运行提供良好的环境，提高存储器的利用率。
 内存分配：静态分配方式和动态分配方式； 地址映射； 内存保护与共享； 虚拟内存等。  3. 文件管理 为用户进程分配I/O设备，提高CPU和I/O设备的利用率。
 文件存储空间的管理； 目录管理； 文件读写管理和保护。  4. 设备管理 完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。
 缓冲管理； 设备分配； 设备处理； 虛拟设备。  1.3 系统调用 如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。
1. 指令划分  特权指令：只能由操作系统使用，如启动I/O、内存清零、修改程序状态字、设置时钟、允许/禁止终端、停机； 非特权指令：用户程序可以使用的指令。如控制转移、算数运算、取数指令、访管指令（使用户程序从用户态陷入内核态）。  2.</description>
    </item>
    
    <item>
      <title>计算机网络</title>
      <link>https://lil-q.github.io/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Tue, 05 May 2020 19:30:17 +0000</pubDate>
      
      <guid>https://lil-q.github.io/blog/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</guid>
      <description>网络把主机连接起来，而互连网（internet）是把多种不同的网络连接起来，因此互连网是网络的网络。
一、概述 1. 主机之间的通信方式   客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。
  对等（P2P）：不区分客户和服务器。
  2. 报文交换  电路交换：整个报文的比特流连续地从源点直达终点，好像在一个管道中传送一样。 报文交换：整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。 分组交换：单个分组（如p1，整个报文的一部分）传送到相邻结点，存储下来后查找转发表，转达到下一个结点。  3. 时延 总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延
（1）排队时延
分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。
（2）处理时延
主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。
（3）传输时延
主机或路由器传输数据帧所需要的时间。
（4）传播时延
电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。
4. 体系结构   应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。
  传输层 ：为进程提供通用的数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。
以上为端到端，以下为点到点：
  网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。
  数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。
  物理层 ：考虑如何在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。
  （1）协议</description>
    </item>
    
  </channel>
</rss>