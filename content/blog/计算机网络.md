---
title: 计算机网络
date: 2020-05-05 19:30:17
tags: [basis, web]
toc: true
description: "计算机网络基础知识"
keywords: [web, 计算机网络]
---

网络把主机连接起来，而互连网（internet）是把多种不同的网络连接起来，因此互连网是网络的网络。

## 一、概述

#### 1. 主机之间的通信方式

- 客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。

- 对等（P2P）：不区分客户和服务器。

#### 2. 报文交换

* 电路交换：整个报文的比特流连续地从源点直达终点，好像在一个管道中传送一样。
* 报文交换：整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。
* 分组交换：单个分组（如p1，整个报文的一部分）传送到相邻结点，存储下来后查找转发表，转达到下一个结点。

![](https://qttblog.oss-cn-hangzhou.aliyuncs.com/after5.5/web1.png)

#### 3. 时延

总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延

![](https://qttblog.oss-cn-hangzhou.aliyuncs.com/after5.5/web2.png)

**（1）排队时延**

分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。

**（2）处理时延**

主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。

**（3）传输时延**

主机或路由器传输数据帧所需要的时间。

**（4）传播时延**

电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。

#### 4. 体系结构

<img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/after5.5/web3.png"  />

- **应用层** ：为特定**应用程序**提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。

- **传输层** ：为**进程**提供**通用的**数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：**传输控制协议 TCP**，提供面向连接、可靠的数据传输服务，数据单位为报文段；**用户数据报协议 UDP**，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。

  以上为**端到端**，以下为**点到点**：

- **网络层** ：为**主机**提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成**分组**。

- **数据链路层** ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组**封装成帧**。

- **物理层** ：考虑如何在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

**（1）协议**

为进行网络中的数据交换而建立的规则、标准或约定称为网络协议。

其中表示层和会话层用途如下：

- **表示层** ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。
- **会话层** ：建立及管理会话。

五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处。

**（2）TCP/IP**

它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。

TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。

**（3）数据在各层之间的传递过程**

在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。

路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。

#### 5. 网站访问全过程

**（1）事件顺序**

1. 浏览器获取输入的**域名**；
2. 浏览器向**域名系统DNS**请求解析域名的**IP地址** ；
3. **DNS**解析出网站服务器的**IP地址** ；
4. 浏览器与该服务器建立**TCP连接**（默认端口号80）；
5. 浏览器发出**HTTP请求**，请求网站首页；
6. 服务器通过**HTTP响应**把首页文件发送给浏览器；
7. **TCP连接**释放；
8. **浏览器**将首页文件进行解析，并将Web页显示给用户。 

**（2）涉及到的协议**    

1. 应用层：**HTTP**（WWW访问协议），**DNS**（域名解析服务）；
2. 传输层：**TCP**（为HTTP提供可靠的数据传输），**UDP**（DNS使用UDP传输）；
3. 网络层：**IP**（IP数据数据包传输和路由选择），**ICMP**（提供网络传输过程中的差错检测），**ARP**（将本机的默认网关IP地址映射成物理MAC地址）。

## 二、链路层

#### 1. 封装成帧

将网络层传下来的分组添加**首部和尾部**，用于标记帧的开始和结束。

#### 2. 透明传输

透明表示一个实际存在的事物看起来好像不存在一样。

帧使用**首部和尾部进行定界**，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。

#### 3. 差错检测

目前数据链路层广泛使用了**循环冗余检验**（CRC）来检查比特差错。

### 2.1 信道分类

#### 1. 广播信道

**一对多通信**，一个节点发送的数据能够被广播信道上所有的节点接收到。

所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。

主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。

#### 2. 点对点信道

**一对一通信**，因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。

### 2.2 CSMA/CD 协议

CSMA/CD 表示载波监听多点接入 / 碰撞检测。

- **多点接入** ：说明这是**总线型网络**，许多主机以多点的方式连接到总线上。
- **载波监听** ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。
- **碰撞检测** ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。

记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 **争用期** 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。

当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 **截断二进制指数退避算法** 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。

### 2.3 PPP 协议

互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。

### 2.4 MAC 地址

MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。

一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。

## 三、网络层

### 3.1 网际互连协议 IP

IP是整个TCP/IP协议族的核心，也是构成互联网的基础。IP 地址的编址方式经历了三个历史阶段：

- 分类：{< 网络号 >, < 主机号 >}
- 子网划分：{< 网络号 >, < 子网号 >, < 主机号 >}
- 无分类：{< 网络前缀号 >, < 主机号 >}

### 3.2 地址解析协议 ARP

网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。

每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 **IP 地址到 MAC 地址**的映射表。

如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过**广播**的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。

![](https://qttblog.oss-cn-hangzhou.aliyuncs.com/after5.5/web5.png)

### 3.3 网际控制报文协议 ICMP

ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。

### 3.4 虚拟专用网VPN

由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。

VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指实际上并不是物理上的专用网，而是经过公用的互联网并加密实现的。

**网络地址转换 NAT**

专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。

### 3.5 路由器

路由器从功能上可以划分为：路由选择和分组转发。

分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。

**路由器分组转发流程**

- 从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。
- 若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；
- 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；
- 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；
- 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；
- 报告转发分组出错。

## 四、传输层

**UDP 和 TCP 的特点**

- **用户数据报协议**（**U**ser **D**atagram **P**rotocol，**UDP**）是**无连接**的，尽**最大可能**交付，**没有拥塞控制**，**面向报文**（对于应用程序传下来的报文**不合并也不拆分**，只是添加 UDP 首部），支持**一对一**、**一对多**、**多对一**和**多对多**的交互通信。
- **传输控制协议**（**T**ransmission **C**ontrol **P**rotocol，**TCP**）是**面向连接**的，提供**可靠**交付，有**流量控制**，**拥塞控制**，提供**全双工通信**，**面向字节流**（把应用层传下来的报文看成字节流，把字节流**组织成大小不等的数据块**），每一条 TCP 连接只能是**点对点**的（一对一）。

### 4.1 TCP 三次握手

![](https://qttblog.oss-cn-hangzhou.aliyuncs.com/after5.5/web6.png)

- 首先服务器处于 LISTEN（监听）状态，等待客户的连接请求。
- 客户端向服务器发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。
- 服务器收到连接请求报文，如果同意建立连接，则向客户端发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。
- 客户端收到服务器的连接确认报文后，还要向服务器发出确认，确认号为 y+1，序号为 x+1。
- 服务器收到客户端的确认后，连接建立。

**三次握手的原因**

第三次握手是为了防止失效的连接请求到达服务器，让服务器**错误打开重复连接**。

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

### 4.2 TCP 四次挥手

![](https://qttblog.oss-cn-hangzhou.aliyuncs.com/after5.5/web7.png)

序号和确认号的规则比较简单； ACK 在连接建立之后都为 1。

- 客户端发送连接释放报文，FIN=1。
- 服务器收到之后发出确认，此时 TCP 属于半关闭状态，服务器能向客户端发送数据但是客户端不能向服务器发送数据。
- 当服务器不再需要连接时，发送连接释放报文，FIN=1。
- 客户端收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。
- 服务器收到客户端的确认后释放连接。

**四次挥手的原因**

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让**服务器端发送还未传送完毕的数据**，传送完毕之后，服务器会发送 FIN 连接释放报文。

**TIME_WAIT**

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL（*Maximum Segment Lifetime*，报文最大生存时间）。这么做有两个理由：

- 确保最后一个确认报文能够到达。如果服务器没收到客户端发送来的确认报文，那么就会重新发送连接释放请求报文，客户端等待一段时间就是为了处理这种情况的发生。
- 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

### 4.3 TCP 流量控制 & 拥塞控制

**流量控制**和**拥塞控制**共同决定了发送的速率，`发送窗口 = min(拥塞窗口，接收窗口)`。

#### 1. 流量控制

**点对点**通信量的控制，流量控制要做的是抑制发送端发送数据的速率，以便使接收端来得及接收 。

**发送窗口**（swnd）和**接收窗口**（rwnd）中所存放的字节数都放在操作系统内存缓冲区中，操作系统缓冲区的调整能影响窗口的大小。TCP 通过让接收方指明希望从发送方接收的数据大小（窗口大小）来进行流量控制。如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这段时间**窗口关闭**。

窗口关闭是存在潜在风险的：接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失，就会导致发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不采取措施，就会形成相互等待的**死锁**。

为了解决死锁问题，TCP 为每个连接设置一个**持续定时器**，只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。如果持续计时器超时，就会发送**窗口探测（Window probe）报文**，而对方在收到这个探测报文后，给出当时的接收窗口大小：

* 接收窗口不为 0，死锁的局面就被打破了；
* 接收窗口仍然为 0，那么收到这个报文的一方会重新启动持续计时器；
* 接受窗口连续三次为 0，TCP 实现可能会发 `RST` 报文来中断连接。

#### 2. 拥塞控制

作用于**网络**，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。拥塞控制是一个**全局性**的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。 

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让**接收方能来得及接收**，而拥塞控制是为了**降低整个网络的拥塞程度**。

发送方需要维护一个叫做**拥塞窗口**（cwnd）的状态变量，TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。

**（1）慢开始**

发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...

**（2）拥塞避免**

注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限（**s**low **s**tart **thresh**old，**ssthresh**），当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。

如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。

**（3）快重传**

当网络出现拥塞，就会发生数据包重传，重传机制主要有两种：**超时重传**和**快速重传**。

**超时重传**

重新慢开始（会造成网络卡顿）：

- `ssthresh = cwnd/2` 
- `cwnd = 1`

**快速重传**

在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。在发送方，如果收到**三个重复确认**，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3，之后：

- `cwnd = cwnd/2` 
- `ssthresh = cwnd`
- 进入快速恢复算法

**（4）快恢复**

快速重传和快速恢复算法一般同时使用，在`cwnd = cwnd/2` &  `ssthresh = cwnd`之后：

* 拥塞窗口 `cwnd = ssthresh + n` （ 确认有 n 个数据包已接受）
* 重传丢失的数据包
* 如果再收到重复的 ACK，那么 cwnd 增加 1
* 如果收到新数据的 ACK 后，设置 cwnd 为 ssthresh，接着就进入了拥塞避免算法

### 4.4 MTU & MSS

![mssmtu](https://qttblog.oss-cn-hangzhou.aliyuncs.com/june/webnew1.png)

**最大传输单元**（**M**aximum **T**ransmission **U**nit，**MTU**）：在 TCP/IP 协议族中，指的是 **IP 数据报**能经过一个**物理网络**的最大报文长度，其中包括了 IP 首部(从 20 个字节到 60 个字节不等)，一般以太网的 MTU 设为 1500 bytes，如果数据大于 1500 bytes，需要分片才能完成发送，这些分片有一个共同点，即 IP Header ID 相同。

**最大报文段大小**（**M**aximum **S**egment **S**ize，**MSS**）：指的是 **TCP** 提交给 **IP 层**的最大数据报长度，其中不包括 TCP 首部长度。**MSS 由 TCP 链接的过程中由双方协商得出**（取较小值），其中 SYN 字段中的选项部分包括了这个信息。如果 MSS + TCP 首部 + IP 首部大于 MTU，那么 IP 报文就会分片，如果小于，那么就可以不需要分片正常发送。

**IP** 和 **TCP** 具有分片的能力，而 UDP 没有，比如应用层中的 DNS 协议在发现报文大于 512 字节时会使用 TCP 来传输。

## 五、应用层

### 5.1 HTTP & HTTPS

- HTTPS 其实就是建构在 **SSL** / **TLS** 之上的 HTTP 协议，HTTPS 比 HTTP **更耗费服务器资源**。
- HTTP 明文传输，数据未加密，安全性较差，HTTPS 传输过程中数据加密，**安全性较好**。
- HTTPS 协议需要到 **CA** 申请证书。
- HTTP 页面响应速度比 HTTPS 快（HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包； HTTPS 除了 TCP 的三个包，还要加上 SSL 握手需要的 9 个包，一共是 12 个包）。
- HTTP 默认端口为 80，HTTPS为 443。

> **传输层安全性协议**（**T**ransport **L**ayer **S**ecurity，**TLS**）及其前身**安全套接层**（**S**ecure **S**ockets **L**ayer，**SSL**）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。
>
> **数字证书认证机构**（**C**ertificate **A**uthority，**CA**）是负责发放和管理**数字证书**的权威机构

### 5.2 socket

**Socket** 是在应用层和传输层之间的一个**抽象层**，它把 TCP/IP 层复杂的操作抽象为几个简单的接口，供应用层调用实现进程在网络中的通信。Socket 起源于 UNIX，在 UNIX 一切皆文件的思想下，进程间通信就被冠名为`文件描述符（file descriptor）`，Socket 是一种**打开—读/写—关闭**模式的实现，服务器和客户端各自维护一个文件，在建立连接打开后，可以向文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。

<img src="https://qttblog.oss-cn-hangzhou.aliyuncs.com/june/webnew2.png" alt="socket" style="zoom:125%;" />

TCP/IP 只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。就像操作系统会提供标准的编程接口，比如 Win32 编程接口一样，TCP/IP 也必须对外提供编程接口，这就是 Socket。

Socket 跟 TCP/IP 并没有必然的联系。Socket 编程接口在设计的时候，就希望也能适应其他的网络协议。所以，Socket 的出现只是可以更方便的使用 TCP/IP 协议栈而已，其对 TCP/IP 进行了抽象，形成了几个最基本的函数接口。比如 create，listen，accept，connect，read 和 write 等。不同语言都有对应的建立Socket服务端和客户端的库。

![s2](https://qttblog.oss-cn-hangzhou.aliyuncs.com/june/webnew3.png)



## 参考

1. [网站访问全过程](https://blog.csdn.net/cream66/article/details/104920732?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param)
2. [MTU & MSS](https://www.imperva.com/blog/mtu-mss-explained/)
3. [关于分片](https://www.zhihu.com/question/68641339)
4. [sokect通信原理](https://segmentfault.com/a/1190000013712747)
5. [图解TCP 重传、滑动窗口、流量控制、拥塞控制](https://www.nowcoder.com/discuss/414727?type=all&order=time&pos=&page=1&channel=1013&source_id=search_all)

